<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MBRjun-Blog</title>
  
  
  <link href="https://www.mbrjun.cn/atom.xml" rel="self"/>
  
  <link href="https://www.mbrjun.cn/"/>
  <updated>2025-04-14T11:41:02.000Z</updated>
  <id>https://www.mbrjun.cn/</id>
  
  <author>
    <name>MBRjun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TLS 证书有效期将缩短至 47 天</title>
    <link href="https://www.mbrjun.cn/archives/505/"/>
    <id>https://www.mbrjun.cn/archives/505/</id>
    <published>2025-04-14T11:41:02.000Z</published>
    <updated>2025-04-14T11:41:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>根据 Apple 的提案，TLS 证书（也称为 SSL 证书）证书的最长有效期将逐步缩短至 47 天。随着此改变，证书自动化部署将会变得越来越重要，人工更新证书最终将被淘汰。  </p><span id="more"></span><p>由国际性电子认证机构（CA）与操作系统、浏览器厂商组成的CA&#x2F;B论坛（CA &#x2F; Browser Forum）投票通过由苹果公司（Apple）最早提出的 <a href="https://groups.google.com/a/groups.cabforum.org/g/servercert-wg/c/9768xgUUfhQ">SC-081v3</a> 号提案。  </p><p>提案指出，缩短证书有效期可以降低因信息陈旧带来的安全风险，并弥补证书撤销机制的不足。更短的有效期迫使组织采用自动化证书管理流程，提升整体管理水平和安全性，同时减少人工错误并更快响应潜在威胁。  </p><h2 id="有效期缩短计划"><a href="#有效期缩短计划" class="headerlink" title="有效期缩短计划"></a>有效期缩短计划</h2><p>TLS 服务器证书的最长有效期将<strong>分阶段</strong>逐步缩短，以确保现有服务能有时间适应改变。现在的状态及未来的计划如下：</p><table><thead><tr><th>日期</th><th>证书最长有效期</th></tr></thead><tbody><tr><td>2020-09-01 后</td><td>398 天</td></tr><tr><td>2026-03-15 后</td><td>200 天</td></tr><tr><td>2027-03-15 后</td><td>100 天</td></tr><tr><td>2029-03-15 后</td><td>47 天</td></tr></tbody></table><h2 id="历史上的有效期缩短"><a href="#历史上的有效期缩短" class="headerlink" title="历史上的有效期缩短"></a>历史上的有效期缩短</h2><p>2011 年，CA&#x2F;B 论坛将证书有效期从最初的 8-10 年缩短至 5 年；2015 年进一步缩短为 3 年；2018 年再次调整为 2 年。尽管 2019 年 CA&#x2F;B 论坛投票否决了将有效期缩短至一年的提议，但这一措施获得了苹果、谷歌、微软、Mozilla 和 Opera 等主要浏览器厂商的支持。随后，2020 年 2 月，苹果宣布拒绝接受有效期超过 398 天（约一年）的新证书，并在同年 9 月 1 日后严格执行此政策。此后，Google 和 Mozilla 也相继效仿，进一步推动了证书有效期缩短的趋势。  </p><h2 id="自动化续订的重要性"><a href="#自动化续订的重要性" class="headerlink" title="自动化续订的重要性"></a>自动化续订的重要性</h2><p>自动化续订对于缓解证书有效期缩短带来的问题至关重要。随着证书更新频率的增加，意外过期的风险也随之上升。自动化策略通过简化证书生命周期管理，覆盖从申请、颁发到续订和吊销的每个阶段，减少了人工干预的需求。这种方法不仅提高了效率，还增强了可靠性，尤其在管理大量 SSL 证书时，能够有效防止证书过期，确保安全性和业务连续性。</p><h2 id="不应继续人工预订"><a href="#不应继续人工预订" class="headerlink" title="不应继续人工预订"></a>不应继续人工预订</h2><p>证书有效期开始缩短后，手动管理证书流程本身就不切实际，而证书有效期缩短至最长 47 天将加剧现有问题。简而言之，IT 部门根本无法应对。随着 TLS 证书数量不断增加，有效管理这些证书将变得越来越困难。假设未来使用最长有效期 47 天的证书，一年将至少要续订 8 次，如果服务器证书大规模部署，使用手动续费，每次操作都可能需要几十分钟的时间。随着需要续订次数增加，需要的人力成本将成倍增加，发生人为错误的风险也将提高。在有效期缩短后，自动化部署每年可能只会多消耗几十 MB 流量，而人工部署每年很可能需要总共几个小时的时间。</p><h2 id="做好准备"><a href="#做好准备" class="headerlink" title="做好准备"></a>做好准备</h2><p>仍在手动续费并管理证书的用户应当尽早考虑自动化部署，现在就进行自动化部署可以立刻享受到其带来的优势以及管理成本的降低。提前做好测试部署也可以有更充足的时间应对意外。如果认为修改不支持自动续订的遗留系统需要更长时间，您也可以考虑在缩短有效期的截止时间前 1 个月再次购买最后一张 1 年有效期的证书。  </p><p>目前，有很多优秀的证书自动化管理工具可以全自动完成证书的购买、续订、部署等过程，例如本站正在使用 <a href="https://acme.sh/">acme.sh</a> 来自动签发证书。您还可以考虑 CertBot 或其他工具。  </p><h2 id="本站"><a href="#本站" class="headerlink" title="本站"></a>本站</h2><p>本站目前使用 <a href="https://pki.goog/">GTS</a> 颁发的证书，有效期均为 90 天。  </p><p>一旦相关工具链对短周期证书完成适配，本站将尽可能早的切换到 30 天或更短有效期的短周期证书。  </p><p>本站的证书自动申请使用 <a href="https://acme.sh/">acme.sh</a>，服务器自动部署采用 NFS、rsync 配合自有工具实现，CDN 和云加速自动部署将会使用自维护的 CI&#x2F;CD 实现。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;根据 Apple 的提案，TLS 证书（也称为 SSL 证书）证书的最长有效期将逐步缩短至 47 天。随着此改变，证书自动化部署将会变得越来越重要，人工更新证书最终将被淘汰。  &lt;/p&gt;</summary>
    
    
    
    <category term="网络" scheme="https://www.mbrjun.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TLS" scheme="https://www.mbrjun.cn/tags/TLS/"/>
    
    <category term="证书" scheme="https://www.mbrjun.cn/tags/%E8%AF%81%E4%B9%A6/"/>
    
    <category term="SSL" scheme="https://www.mbrjun.cn/tags/SSL/"/>
    
    <category term="CA" scheme="https://www.mbrjun.cn/tags/CA/"/>
    
  </entry>
  
  <entry>
    <title>IPv6 配置常见问题 Linux 篇 Ⅰ</title>
    <link href="https://www.mbrjun.cn/archives/504/"/>
    <id>https://www.mbrjun.cn/archives/504/</id>
    <published>2025-04-12T11:41:02.000Z</published>
    <updated>2025-04-12T11:41:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着 IPv4 资源枯竭和 IPv6 的发展，越来越多的人开始为自己的网络部署 IPv6，本文章总结一下自己和朋友踩过的坑。 </p><p>本文章仅提及标准 Linux 和 OpenWrt 上的 IPv6 配置 ，不包含 Android 等特殊操作系统。其他操作系统的配置我后续将在其他文章单独讨论。</p><span id="more"></span><h2 id="ndisc-router-discovery-failed-to-add-default-route"><a href="#ndisc-router-discovery-failed-to-add-default-route" class="headerlink" title="ndisc_router_discovery failed to add default route"></a>ndisc_router_discovery failed to add default route</h2><p>是一个内核报错信息，完整的是 <code>ICMPv6: RA: ndisc_router_discovery failed to add default route</code>  </p><p>一般此问题多在配置<strong>静态 IPv6</strong> 的机器出现。  </p><p>错误的原因是：已经设置了静态网关，但是 RA 没有关闭。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">net.ipv6.conf.INTERFACE.accept_ra=0<br></code></pre></td></tr></table></figure><p><em>INTERFACE</em> 替换为网络接口，也可以使用 all 和 default 设置所有接口或默认值<br>添加至 <code>/etc/sysctl.conf</code>，运行 <code>sysctl -p</code> 保存</p><hr><h2 id="开启-IP-转发后-IPv6-地址丢失"><a href="#开启-IP-转发后-IPv6-地址丢失" class="headerlink" title="开启 IP 转发后 IPv6 地址丢失"></a>开启 IP 转发后 IPv6 地址丢失</h2><p>开启 IP 转发后默认禁止接收 RA，可以通过以下方式恢复  </p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">net.ipv6.conf.all.accept_ra=2<br>net.ipv6.conf.default.accept_ra=2<br></code></pre></td></tr></table></figure><p>添加至 <code>/etc/sysctl.conf</code>，运行 <code>sysctl -p</code> 保存</p><hr><h2 id="IPv6-DUID-不固定"><a href="#IPv6-DUID-不固定" class="headerlink" title="IPv6 DUID 不固定"></a>IPv6 DUID 不固定</h2><p>路由器上已经为 Linux 主机设置了静态 DHCPv6 分配，但是主机重启后无法获取 IPv6 或获取的地址不一致，检查发现是 DUID 改变。</p><p>大概率是 <code>ifupdown2</code> 的问题，检查一下系统是不是在用 <code>ifupdown2</code>（一般来说，Proxmox 的系统默认就使用 <code>ifupdown2</code>，其他情况可以通过检测系统是否有 <code>ifreload</code> 命令来判断）  </p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p><a href="https://github.com/CumulusNetworks/ifupdown2/pull/326">CumulusNetworks&#x2F;ifupdown2 #326</a>  </p><p>尝试打我写的这个 <a href="https://github.com/CumulusNetworks/ifupdown2/pull/326.patch">Patch</a>。  </p><hr><h2 id="RA-hop-limit-过低"><a href="#RA-hop-limit-过低" class="headerlink" title="RA hop limit 过低"></a>RA hop limit 过低</h2><p>具体表现有：<code>ping</code> IPv6 提示 <code>Time exceeded: Hop limit</code>，curl 等网络工具直接提示 <code>Couldn&#39;t connect to server</code> 和 <code>No route to host</code>  </p><p>原因是 IPv6 RA 中的 hop limit 过低。  </p><p>有朋友向我反馈：他家的某（通信设备大厂）品牌路由器有这个问题，在抓包分析下发现路由器随机发送 hop limit 为 5-12 的 RA，导致网络故障  </p><p><img src="https://cos.mbrjun.cn/IMGS/2025/04/14/62dfa3a6-fcb3-4855-bac7-e3028988ce69.webp" alt="RA with hop limit 5"></p><p>截至 2025，大多数路由器（尤其是家用路由器）的 IPv6 配置功能不全，功能相对全的大概只有新版本的 OpenWrt 和 ROS 了。大多数路由器无法手动设置 IPv6 的 hop limit，所以我们通过<strong>设置 Linux 最低接受的 hop limit</strong> 来解决问题。  </p><h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">net.ipv6.conf.INTERFACE.accept_ra_min_hop_limit=64<br></code></pre></td></tr></table></figure><p><em>INTERFACE</em> 替换为网络接口，也可以使用 all 和 default 设置所有接口或默认值<br>最后的数字即为最小 hop limit。一般设置为 64 即可</p><p>添加至 <code>/etc/sysctl.conf</code>，运行 <code>sysctl -p</code> 保存  </p><div class="alert warning"><p><strong>反对盲目蛮干！</strong><br><img src="https://cos.mbrjun.cn/IMGS/2025/04/14/81a5f63e-d46d-4d61-aa2a-1efc559e6ce3.webp" alt="ra min hop limit not set"></p></div><hr><h2 id="IPv6-配置中继后-LAN-设备还是没有地址"><a href="#IPv6-配置中继后-LAN-设备还是没有地址" class="headerlink" title="IPv6 配置中继后 LAN 设备还是没有地址"></a>IPv6 配置中继后 LAN 设备还是没有地址</h2><p>检查下 wan6 口的 master 有没有勾上（部分老版本 wrt 可能使用 wan 而不是 wan6 作为接口名）  </p><p><img src="https://cos.mbrjun.cn/IMGS/2025/04/14/6a27826c-783d-4b71-bd39-50e44ddfbc6e.webp" alt="IPv6 relay master"></p><h4 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>勾上主接口<br>部分老版本 wrt 图形化找不到这个设置，修改 <code>/etc/config/dhcp</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">config dhcp wan6<br>  option dhcpv6 relay<br>  option ra relay<br>  option ndp relay<br>  option master 1<br></code></pre></td></tr></table></figure>在 wan6 添加 master 配置</li><li>另外，如果你的 OpenWrt 有 ULA 前缀 这个设置，把他清空并保存。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着 IPv4 资源枯竭和 IPv6 的发展，越来越多的人开始为自己的网络部署 IPv6，本文章总结一下自己和朋友踩过的坑。 &lt;/p&gt;
&lt;p&gt;本文章仅提及标准 Linux 和 OpenWrt 上的 IPv6 配置 ，不包含 Android 等特殊操作系统。其他操作系统的配置我后续将在其他文章单独讨论。&lt;/p&gt;</summary>
    
    
    
    <category term="网络" scheme="https://www.mbrjun.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="Linux" scheme="https://www.mbrjun.cn/tags/Linux/"/>
    
    <category term="IPv6" scheme="https://www.mbrjun.cn/tags/IPv6/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 反代缓存的基础配置</title>
    <link href="https://www.mbrjun.cn/archives/503/"/>
    <id>https://www.mbrjun.cn/archives/503/</id>
    <published>2025-04-03T16:02:23.000Z</published>
    <updated>2025-04-03T16:02:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx 反代默认不缓存，部分场景下，默认配置可能会使源站压力过高并降低网站性能。在这里写一下 Nginx 缓存的配置方法。</p><span id="more"></span><h2 id="反代缓存"><a href="#反代缓存" class="headerlink" title="反代缓存"></a>反代缓存</h2><p>和浏览器缓存的机制类似，不过内容缓存在 Nginx 中。  </p><p><img src="https://cos.mbrjun.cn/IMGS/2025/04/04/c288819e-40a5-4f37-8aa2-fdabe911f662.webp" alt="Nginx Cache"></p><p>浏览器缓存一般只保留在用户电脑的内存或磁盘中，关闭浏览器就会清除缓存，且多个用户不能直接共享相同的缓存。  </p><p>反代侧添加缓存在静态资源较多、用户量大、源站性能不佳时对性能改善比较明显，缓存保存在服务器内存或硬盘中，缓存时间和大小均可自定义。多个用户访问同一静态资源，Nginx 只需要向源服务器访问一次。  </p><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p>在 Nginx 的 HTTP 块中加入下面的内容：  </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">proxy_cache_path</span> /var/cache/nginx levels=<span class="hljs-number">1</span>:<span class="hljs-number">2</span> keys_zone=global:<span class="hljs-number">30m</span> max_size=<span class="hljs-number">1800m</span> inactive=<span class="hljs-number">365d</span> use_temp_path=<span class="hljs-literal">off</span>;<br></code></pre></td></tr></table></figure><p>参数解释：  </p><ul><li><code>/var/cache/nginx</code><br>指定一个绝对路径作为缓存存储目录</li><li><code>levels=1:2</code><br>缓存目录结构，第一级目录使用 1 个字符，第二级目录使用 2 个字符<br>最终效果类似 &#x2F;var&#x2F;cache&#x2F;nginx&#x2F;a&#x2F;bc&#x2F;xxxxxxxxxxxx</li><li><code>keys_zone=global:30m</code><br>缓存区域名称和元数据缓存大小<br>元数据缓存（或者叫缓存索引）驻留在内存中，每 MB 约可存储万条缓存项</li><li><code>max_size=1800m</code><br>缓存在磁盘上使用的最大空间<br>填满后，自动删除长期未使用的缓存</li><li><code>inactive=365d</code><br>缓存的最长时间，是保底规则<br>HTTP 标头报告的缓存优先级更高</li><li><code>use_temp_path=off</code><br>先将缓存写入临时目录，再写入设置的目录<br>部分 NFS 或 FUSE 可能需要设置为 on 才能工作</li></ul><p>完成缓存区域的创建以后，为反代的网站开启缓存：  </p><p>以下内容均需要在反代配置下方加入，也可以多个网站共同 include 一个缓存配置。include 用法如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># reverse proxy</span><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span>            http://bw;<br>        <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>        <span class="hljs-attribute">include</span>               conf.d/proxy.conf;<br>        <span class="hljs-attribute">proxy_next_upstream</span>   <span class="hljs-literal">error</span> timeout http_502 http_503 http_504;<br>    &#125;<br></code></pre></td></tr></table></figure><p>然后添加缓存配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">proxy_cache</span> global;<br><span class="hljs-attribute">proxy_cache_valid</span> <span class="hljs-number">301</span>      <span class="hljs-number">7d</span>;<br><span class="hljs-attribute">proxy_cache_valid</span> <span class="hljs-number">404</span>      <span class="hljs-number">1m</span>;<br></code></pre></td></tr></table></figure><p>在 <code>proxy_cache</code> 后加缓存区域名称。最简单的基础配置，Nginx 将根据源站的标头自动进行缓存。</p><p>此处可以添加更多保底规则（一般情况下，非 200 状态码源站很可能不返回缓存控制信息，如果在源站未明确要求是否缓存，就使用此处的规则）  </p><p>不添加任何其他规则时，Nginx 将跟随源站进行缓存。可以改善性能并且一般不会出现访问问题。完整的规则列表请参考<a href="'https://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache'">这里</a>  </p><h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><p>忽略源站配置，强制配置单独的缓存规则：<br>HTTP 块中：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">proxy_cache</span> global;<br><span class="hljs-attribute">proxy_cache_valid</span> <span class="hljs-number">301</span>      <span class="hljs-number">7d</span>;<br><span class="hljs-attribute">proxy_cache_valid</span> <span class="hljs-number">404</span>      <span class="hljs-number">1m</span>;<br><span class="hljs-attribute">proxy_cache_valid</span> any      <span class="hljs-number">5m</span>;<br><span class="hljs-attribute">proxy_ignore_headers</span> Set-Cookie;<br><span class="hljs-attribute">proxy_ignore_headers</span> Cache-Control Expires;<br></code></pre></td></tr></table></figure><div class="alert info"><p>通常不推荐。建议的做法是在源站完善配置，然后 Nginx 配置跟随源站并设置保底规则，而不是完全忽略源站的缓存控制。</p></div><p>完全手动配置缓存更灵活，但是可能导致访问出现问题，下面是一些配置建议：  </p><ul><li>不要缓存网站的登录页面和后台，可能会导致访问失败和数据泄露</li><li>不要缓存网站评论系统，可能会导致无法刷新出评论内容或重复评论。</li></ul><h2 id="ZFS"><a href="#ZFS" class="headerlink" title="ZFS"></a>ZFS</h2><p>缓存在 ZFS 上时，推荐一个配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">zfs create -o mountpoint=/var/cache/nginx -o compression=lz4 -o atime=off -o recordsize=128K -o primarycache=metadata -o secondarycache=none rpool/ngcache<br>zfs <span class="hljs-built_in">set</span> quota=2G rpool/ngcache<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Nginx 反代默认不缓存，部分场景下，默认配置可能会使源站压力过高并降低网站性能。在这里写一下 Nginx 缓存的配置方法。&lt;/p&gt;</summary>
    
    
    
    <category term="教程" scheme="https://www.mbrjun.cn/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="CDN" scheme="https://www.mbrjun.cn/tags/CDN/"/>
    
    <category term="Nginx" scheme="https://www.mbrjun.cn/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>腾讯云轻量手动配置 IPv6</title>
    <link href="https://www.mbrjun.cn/archives/502/"/>
    <id>https://www.mbrjun.cn/archives/502/</id>
    <published>2025-03-10T16:02:23.000Z</published>
    <updated>2025-03-10T16:02:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>Lighthouse 实例手动配置 IPv6 的教程，主要解决重置&#x2F;回滚系统后丢失 IPv6 配置，以及自定义网络划分缺少配置信息的问题</p><span id="more"></span><hr><p>本文章内容不适用于腾讯云 CVM 实例。</p><h2 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h2><p>如果你对 IPv6 已经很了解了，只是需要配置信息，那么你可能只需要这个表格：  </p><table><thead><tr><th>配置项</th><th>配置值</th></tr></thead><tbody><tr><td>IPv6 连接方式</td><td>静态地址</td></tr><tr><td>IPv6 地址</td><td>使用控制台显示的公网 IPv6 地址</td></tr><tr><td>IPv6 前缀长度</td><td>128</td></tr><tr><td>IPv6 子网掩码</td><td><code>ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff</code></td></tr><tr><td>IPv6 网关</td><td><code>fe80::feee:ffff:feff:ffff</code></td></tr><tr><td>IPv6 DNS</td><td>不使用</td></tr><tr><td>RA</td><td>关闭</td></tr><tr><td>DHCPv6</td><td>关闭</td></tr></tbody></table><p>下图蓝框部分即为需要填入的 IPv6 地址：<br><img src="https://cos.mbrjun.cn/IMGS/2025/03/10/3048c954-b696-49a4-95c8-2cb26be99572.webp" alt="腾讯云轻量 IPv6 地址"></p><h2 id="Debian-ifupdown-配置"><a href="#Debian-ifupdown-配置" class="headerlink" title="Debian&#x2F;ifupdown 配置"></a>Debian&#x2F;ifupdown 配置</h2><p><strong>临时配置（重启后失效）：</strong><br>输入下面的命令：  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip -6 addr add 公网 IPv6 地址/128 dev eth0<br>ip -6 route add default via fe80::feee:ffff:feff:ffff dev eth0<br></code></pre></td></tr></table></figure><p><strong>永久配置：</strong><br>编辑 <code>/etc/network/interfaces</code> ，按下面的格式加上  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">iface eth0 inet6 static<br>        address 公网 IPv6 地址/128<br>        gateway fe80::feee:ffff:feff:ffff<br></code></pre></td></tr></table></figure><p><img src="https://cos.mbrjun.cn/IMGS/2025/03/10/3dd80532-2d0c-4084-9668-a014eaf384df.webp" alt="ifupdown IPv6"><br>完成后重启服务器，或者用 <code>ifreload -a</code> 应用（需要 ifupdown2）  </p><h2 id="NetworkManager-配置"><a href="#NetworkManager-配置" class="headerlink" title="NetworkManager 配置"></a>NetworkManager 配置</h2><p>（Debian 以外的部分操作系统使用 NetworkManager）  </p><p><strong>临时配置（重启后失效）：</strong><br>输入下面的命令：  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">nmcli connection modify eth0 ipv6.addresses 公网 IPv6 地址/128<br>nmcli connection modify eth0 ipv6.gateway fe80::feee:ffff:feff:ffff<br>nmcli connection modify eth0 ipv6.method manual<br>nmcli connection up eth0<br></code></pre></td></tr></table></figure><p><strong>永久配置：</strong><br>编辑 <code>/etc/NetworkManager/system-connections/eth0.nmconnection</code> ，按下面的格式加上  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[ipv6]<br>method=manual<br>addresses=公网 IPv6 地址/128<br>gateway=fe80::feee:ffff:feff:ffff<br></code></pre></td></tr></table></figure><p>完成后重启服务器，或者用 <code>nmcli connection reload</code> 应用  </p><h2 id="Windows-配置"><a href="#Windows-配置" class="headerlink" title="Windows 配置"></a>Windows 配置</h2><ol><li>打开控制面板</li><li>网络和共享中心</li><li>点开网络连接，属性</li><li>编辑 TCP&#x2F;IPv6</li><li>按上面基础信息填</li><li>DNS 留空</li><li>保存</li></ol><p>或者我尝试用一张图让你理解：  </p><p><img src="https://cos.mbrjun.cn/IMGS/2025/03/10/c059155b-31fb-4730-9601-d9ff651a866c.webp" alt="Windows set IPv6"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Lighthouse 实例手动配置 IPv6 的教程，主要解决重置&amp;#x2F;回滚系统后丢失 IPv6 配置，以及自定义网络划分缺少配置信息的问题&lt;/p&gt;</summary>
    
    
    
    <category term="教程" scheme="https://www.mbrjun.cn/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="IPv6" scheme="https://www.mbrjun.cn/tags/IPv6/"/>
    
    <category term="腾讯云" scheme="https://www.mbrjun.cn/tags/%E8%85%BE%E8%AE%AF%E4%BA%91/"/>
    
    <category term="云服务器" scheme="https://www.mbrjun.cn/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>iPhone 强制锁 120Hz 高刷的方法</title>
    <link href="https://www.mbrjun.cn/archives/501/"/>
    <id>https://www.mbrjun.cn/archives/501/</id>
    <published>2025-03-10T15:00:39.000Z</published>
    <updated>2025-03-10T15:00:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>有的应用和游戏，比如，Arcaea，没有正确适配 iPhone 的动态刷新率，会导致游玩时锁在 80Hz 或者其他的低刷新率，不过有个很简单的方法来解</p><span id="more"></span><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>先确保低电量模式没开</li><li>设置 - 辅助功能 - 动态效果，检查下最底下的 60Hz 开关是否关闭</li><li><strong>需要强制高刷的时候把录屏打开即可</strong></li></ol><p>已测试 iOS 16 以上的稳定版本，直到本文发布时最新的 iOS 18.3.1 均可用这个方法解锁，有几个 Beta 版本是不行的  </p><p>我也很好奇为啥会有这种神奇的 bug，这个其实 2022 我就遇到了，今天碰巧想到就发出来了。  </p><p>另外这个 Bug 貌似只影响 iPhone，不影响 iPad，Mac 我不知道，我猜没问题  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有的应用和游戏，比如，Arcaea，没有正确适配 iPhone 的动态刷新率，会导致游玩时锁在 80Hz 或者其他的低刷新率，不过有个很简单的方法来解&lt;/p&gt;</summary>
    
    
    
    <category term="教程" scheme="https://www.mbrjun.cn/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="苹果" scheme="https://www.mbrjun.cn/tags/%E8%8B%B9%E6%9E%9C/"/>
    
    <category term="iPhone" scheme="https://www.mbrjun.cn/tags/iPhone/"/>
    
    <category term="Apple" scheme="https://www.mbrjun.cn/tags/Apple/"/>
    
  </entry>
  
  <entry>
    <title>大致是个 2024 年度总结</title>
    <link href="https://www.mbrjun.cn/archives/500/"/>
    <id>https://www.mbrjun.cn/archives/500/</id>
    <published>2024-12-31T15:59:59.000Z</published>
    <updated>2024-12-31T15:59:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>转眼间，2024 年又要过去了。在这辞旧迎新之际，让我来回顾一下我的 2024 年，充满「改变」的一年。  </p><span id="more"></span><hr><p>应该有简介，但是我不知道写点什么。 文笔不好，基本没怎么写过教程以外的文章，是真的不会写简介哇（  </p><p>上面的内容是从 <a href="https://blog.chyk.ink/2023/12/23/my-2023-summary/">斩斩的 2023 总结</a> <del>照抄</del>，哦不，借鉴的（  </p><p><strong>这篇文章是在小米之家的一台展示机上完成的。</strong>  </p><p>先来解释一下上面这句话：  </p><p>写文章的这一天，学校提前放学，两点放了，放学之后跑滨海玩去了，六点半到天河城吃饭，预约取号，然后就有了：  </p><p>《前面有 185 桌》</p><p>好在这家商场有那个很火的长得像洗衣机的能拍的游戏能玩，然后下楼看了一眼，二十多个人在排两台机子。</p><p>于是走到旁边的小米之家，看到一台游戏本，看了下机器参数之后就开始写这东西了。分享下机器参数吧。</p><p>CPU 是 Intel i9-14900HX，比较奇怪的就是搭上了 16GB DDR5-5600 的内存。这年头游戏本难道不都是 32 起步吗，而且 5600 是不是频率略低了（好像笔记本合理点）？  </p><p>机器里自带了 CPU-Z 等测试工具，大概率是其他路人装的，跑了个分，使用 CPU-Z 19.01.64 AVX2 预设，单核 608.3，多核 6268.5。本来以为会比我自己台式机的 13600KF 略高，实际上没到我 13600KF 的一半，我都好奇笔记本 i9 能不能打台式机 i3 了。  </p><p>我对 i9 移动端的印象没有这么差，怀疑这机子是不是散热或者调度有什么问题，也可能是我打开的方式不对吧，总之是直接用默认设置跑的。  </p><h2 id="去过的地方"><a href="#去过的地方" class="headerlink" title="去过的地方"></a>去过的地方</h2><h4 id="北京"><a href="#北京" class="headerlink" title="北京"></a>北京</h4><p>十几次北京吧，基本每个月都去一次了。  </p><p>北京那边有不少朋友，和别人见面也喜欢优先北京，另一个原因是，北京那边有不少银行（唉卡吃，这个下面一会再详细说说）。</p><p>在北京还拍到了知名的 CR400BF-5033，但是没坐，只是拍到了，是 10 月 3 日的下午，国庆假期，从天津站坐 C2006 次列车前往北京，看了眼 rail.re，当时 5033 在跑京津城际，可能有机会看一面。到了天津站发现是用 CR400BF-5077 跑的，达速运行，到达北京南后，在对侧站台发现 5033，于是拍了几张照片</p><p><img src="https://cos.mbrjun.cn/IMGS/2025/01/01/529f73f4-4cd2-4c1a-b81a-158e5bde0b75.webp" alt="CR400BF-5033 停于北京南站"></p><h4 id="廊坊"><a href="#廊坊" class="headerlink" title="廊坊"></a>廊坊</h4><p>前几次去是骑车去北京（这个事后面也要讲讲）路过的，最后一次去是去北京大兴机场，大兴机场航站楼貌似完全在廊坊，所以就分类到这里了。</p><p><img src="https://cos.mbrjun.cn/IMGS/2025/01/01/385cc2aa-94e9-4027-b00c-48b87cfce327.webp" alt="大兴机场"></p><h4 id="秦皇岛"><a href="#秦皇岛" class="headerlink" title="秦皇岛"></a>秦皇岛</h4><p>取得了第一次上高速的成就，都是绿色牌子好好看。  </p><p><img src="https://cos.mbrjun.cn/IMGS/2025/01/01/9e8b86cd-a837-4f6f-b2d8-17937cc26349.webp" alt="雨雪天气 桥上慢行"></p><h2 id="面过的人"><a href="#面过的人" class="headerlink" title="面过的人"></a>面过的人</h2><h4 id="一刀斩"><a href="#一刀斩" class="headerlink" title="一刀斩"></a>一刀斩</h4><p>很可爱的大佬，东北大学的大学生，Linux GUI 的用户（甚至是触屏而且是 ARM）。  </p><p>他的 Blog 在<a href="https://blog.chyk.ink/">这里</a>。</p><h4 id="流星"><a href="#流星" class="headerlink" title="流星"></a>流星</h4><p>大概是因为 maimai 和那个叫钟致远的人才相识的。是音击厨，也会打 maimai，中二就比较少了，现在打 Arcaea 又比较多。  </p><h4 id="Kt"><a href="#Kt" class="headerlink" title="Kt"></a>Kt</h4><p>好像和我一起开了 BEIJING PASS，是软粉，曾在大兴机场给我展示可以 360 度折的 Surface Book 2。（这机器支持独显热插拔，真的很酷  </p><p><img src="https://cos.mbrjun.cn/IMGS/2025/01/01/122d56c9-99dd-4e2f-ae83-adbb3406a935.webp" alt="Surface Book 2"></p><h4 id="剪贴板"><a href="#剪贴板" class="headerlink" title="剪贴板"></a>剪贴板</h4><p>好像是衡水的学生，是因为 BEIJING PASS 认识的  </p><h4 id="ACh"><a href="#ACh" class="headerlink" title="ACh"></a>ACh</h4><p>盐酸乙酰胆碱，也是大佬，后面就不会描述了呜呜（  </p><h4 id="天王寺喵苑"><a href="#天王寺喵苑" class="headerlink" title="天王寺喵苑"></a>天王寺喵苑</h4><p>貌似也是通过 maimai 认识，在某个下午带着我开了一张卡。  </p><h4 id="186526"><a href="#186526" class="headerlink" title="186526"></a>186526</h4><p>北京的卡吃，ARIN 的 LIR，不打乌蒙，运营着 <a href="https://sunoaki.net/">Sunoaki Network</a>  </p><h4 id="一穗灯花"><a href="#一穗灯花" class="headerlink" title="一穗灯花"></a>一穗灯花</h4><p>很可爱，曾经是 NixOS 用户，貌似为 NixOS 打包了不少软件。  </p><hr><p>不知道有没有列全，如果我不小心忘记了，或者想修改上面的内容，也可以在评论区叫我改改（？  </p><p>上面的大佬大多数都是 Linux 用户，一刀斩曾经使用 Arch，现在使用 AOSC，Kt 是 EL 粉，Ach 186 和流星用的应该都是基于 Debian 的发行版。  </p><h2 id="铁路迷"><a href="#铁路迷" class="headerlink" title="铁路迷"></a>铁路迷</h2><p><del>半吊子车迷，一定是群友把我变成这样的！</del>  </p><p>目前有收集报销凭证&#x2F;车票，以及去各个站打卡的习惯。  </p><p>今年坐过比较多的是京津城际，D9&#x2F;D11，1461&#x2F;2  </p><p><img src="https://cos.mbrjun.cn/IMGS/2025/01/01/318bd150-3275-4942-8fb1-ee9e376f9021.webp" alt="MBR 2024 坐过的火车"></p><p>再聊聊地铁？  </p><p>北京地铁支持外卡和万事网联，好先进啊（  </p><p>天津地铁莫名其妙的不支持工商的银联  </p><p>天津地铁津静线和 11 号线西段已经看过了，北京三号线还没有看过，预计寒假第一天就去看看。  </p><h2 id="卡吃"><a href="#卡吃" class="headerlink" title="卡吃"></a>卡吃</h2><p><del>一定是群友把我变成这样的！</del>  </p><p>好吧多开几张银行卡确实有用，一个是刷卡的时候有优惠，一个是向境外商户付款也方便点。  </p><p>今年开了广发的 AMEX、工银的小飞机（牡丹国际借记卡，万事达版）、招商的方舟卡面银联。  </p><p>前一张是天津本地开的，非柜，第一次见到这卡因为未成年就非柜。后两张是北京，开的都很爽快。  </p><ul><li>工银小飞机就是 10 月 3 日开的，看 5033 的那一天</li><li>招行是天王寺喵苑带着开的，我最早的银联好像也是她推荐的。</li></ul><h2 id="骑行"><a href="#骑行" class="headerlink" title="骑行"></a>骑行</h2><p>应该是有必要提一下了，今年试了下长途骑车，和同学跑了几次天津到北京的往返。  </p><p>路况挺不错的，不算太累，共享单车的话一次 12 元。有一次骑的时候气温有 36 摄氏度，放点图吧：  </p><p><img src="https://cos.mbrjun.cn/IMGS/2025/01/01/cb50c517-7964-424b-82d8-2891f163279b.webp" alt="骑车进京 1"></p><p><img src="https://cos.mbrjun.cn/IMGS/2025/01/01/3c25327c-83d7-44f8-91db-ea7b23f0de42.webp" alt="骑车进京 2"></p><h2 id="游戏相关"><a href="#游戏相关" class="headerlink" title="游戏相关"></a>游戏相关</h2><p>今年玩的 maimai 感觉更少了，也许是因为搬家搬到了附近没有机厅的地方。  </p><p>国服 RATING 11661，当前版本（2024）游玩次数 0<br>日服 RATING 05244，当前版本（PRI-）游玩次数 0<br>u.七个字母.三个字母 RATING 10027，当前版本（PRI-）游玩次数 1</p><p>目前还没有中二和音击的号，但是 2025 会考虑。</p><h2 id="校园"><a href="#校园" class="headerlink" title="校园"></a>校园</h2><p>新校区破破烂烂的，但是有不少大佬。  </p><p><del>不知道写啥，放点我们化学老师的名言吧（？</del></p><p>化学的尽头是物理，物理的尽头是数学，数学的尽头是什么？（停顿半分钟）是哲学。所以我们一直都在思考的是一个哲学问题。远看朝气蓬勃，茂盛葱绒，近看杂草丛生。  </p><h2 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h2><p>今年获得了两个域名：  </p><ul><li>kmbr.dev<br>基本是解析内网设备用，一些自用服务也会放在这个域名</li><li>4.e.e.0.4.8.0.6.0.4.2.ip6.arpa<br>玩具！他甚至可以建站：<a href="https://the-a-record.4.e.e.0.4.8.0.6.0.4.2.ip6.arpa/">The A Record on ARPA</a></li></ul><p>MOEFIRE 给我的 IP 段：  </p><ul><li>2406:840:ee4d::&#x2F;48<br>内部拆成了两个 &#x2F;56，两个 &#x2F;64 来用</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>完善了 <a href="https://github.com/K19B/Kalium.Core">Kalium Bot</a>，写 maimai 自动化查分器写了一半w  </p><p>感觉没有可以继续说的了，那就，总结？</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><del>其实只是又活过了一年罢了</del>  </p><p>人类好奇怪啊，居然会庆祝他们的地球又转了一圈.webp  </p><p>可能是因为上学忙了一点，今年干的事好像比去年要少了。  </p><p>所以，2025，还会继续努力的！  </p><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>本文章的编写参考了以下内容：</p><ul><li><a href="https://blog.chyk.ink/2023/12/23/my-2023-summary/">📜 我的 2023：新的改变，新的成长，新的开始 - 風雪城</a></li><li><a href="https://blog.awaae001.top/posts/57024.html">再见2024 · 共赴一场烟火绚烂 - 呓语梦轩</a></li></ul><p>别的大佬都好厉害啊，年度总结都能写出几万字的，羡慕了（  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;转眼间，2024 年又要过去了。在这辞旧迎新之际，让我来回顾一下我的 2024 年，充满「改变」的一年。  &lt;/p&gt;</summary>
    
    
    
    <category term="日常" scheme="https://www.mbrjun.cn/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="2024" scheme="https://www.mbrjun.cn/tags/2024/"/>
    
    <category term="跨年" scheme="https://www.mbrjun.cn/tags/%E8%B7%A8%E5%B9%B4/"/>
    
    <category term="2025" scheme="https://www.mbrjun.cn/tags/2025/"/>
    
    <category term="年度总结" scheme="https://www.mbrjun.cn/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Hyper-V / KVM 中 VM 的时间同步</title>
    <link href="https://www.mbrjun.cn/archives/499/"/>
    <id>https://www.mbrjun.cn/archives/499/</id>
    <published>2024-10-18T00:00:00.000Z</published>
    <updated>2024-10-18T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟化环境中 VM 的时间同步是很重要的，时间失去同步可能导致诸如 Git、APT、SSL&#x2F;TLS 等很多服务出现异常，而虚拟机的系统时间还容易受到休眠和在线迁移的影响。  </p><p>在生产环境常用的 Hyper-V 和 QEMU&#x2F;KVM 中，如何优雅地使虚拟机的系统时间和外部时间保持同步呢？  </p><span id="more"></span><hr><p>虚拟机中的时间同步大致有两种方案：</p><ul><li>和网络时间（NTP 服务器）同步</li><li>和宿主机时间同步</li></ul><p>大多数系统中已经默认配置了第一种 NTP 时间同步，然而，虚拟机中使用第一种方法需要可靠的网络连接，且更容易受到外部因素（休眠、在线迁移等）影响。  </p><p>而第二种方法只需要<strong>保证宿主机时间精确</strong>（Azure 和其他大多数 VPS 的服务商其实也都做到了这个），然后让虚拟机跟随宿主机时钟同步即可，使用这种方法通常精准度会更高，性能开销也稍低一些。</p><p>所以在此只介绍第二种方法，适用于 Hyper-V 和 QEMU&#x2F;KVM，包括 Proxmox VE 等基于 QEMU 魔改的虚拟机也可以，这些虚拟机程序和 VM 时间同步都使用 PTP 协议，简单的介绍一下 PTP：</p><h2 id="PTP"><a href="#PTP" class="headerlink" title="PTP"></a>PTP</h2><p>即 Precision Time Protocol，精确时间协议，PTP 提供微秒级的精度，适用于要求极高时间同步的场景，而常见的 NTP 通常只提供毫秒级的精度，PTP 使用主从模式，主时钟负责同步所有从时钟，通常更适用于局域网环境；NTP 较简单，适合广域网和互联网同步。</p><p>确保宿主机时间精确之后，照着下面的说明为虚拟机开启时间同步</p><h2 id="宿主机操作"><a href="#宿主机操作" class="headerlink" title="宿主机操作"></a>宿主机操作</h2><p>在宿主机上为虚拟机启用 PTP 时间同步设备</p><ul><li>Hyper-V<br>虚拟机设置里找到 <code>Integration Services</code>，勾上 <code>Time Synchronization</code>，保存<br>理论上所有 Hyper-V 版本都支持这个<br><img src="https://cos.mbrjun.cn/IMGS/2024/10/17/f7616c12-2e22-4770-b0d6-aa7e0c8a2486.webp" alt="Hyper-V Time Synchronization Option"></li><li>QEMU&#x2F;KVM<br>默认应该是自动启用的，如果你坚信他没启用，可以试试把 <code>-device kvm-ptp</code> 塞进 QEMU 参数（大模型说的，笔者感觉这个参数没用，加了可能反而会炸）<br>翻了一下<a href="https://github.com/qemu/qemu/blob/278f064e452468d66ee15c3f453826e697ec6832/linux-headers/linux/kvm.h#L1085">源码</a>和提交记录，QEMU 是从 <a href="https://github.com/qemu/qemu/commit/278f064e452468d66ee15c3f453826e697ec6832#diff-f0554892534433bf896e94596ccf7ccad90ebebfc09486a0757b1a4f2ee10c1dR1085">7ec6832</a>（6.0.50 或 6.1 的开发版本） ，2021 年 6 月 18 日开始支持时间同步特性的，太老的版本也许是没有的</li></ul><h2 id="Linux-VM"><a href="#Linux-VM" class="headerlink" title="Linux VM"></a>Linux VM</h2><p>Linux 中推荐使用 <code>chrony</code> 来设置时间同步，部分发行版自带了不支持 PTP 协议的 <code>systemd-timesyncd</code>，少部分发行版默认就提供了配置好的 <code>chrony</code>。</p><p>我们这时候通过 <code>chronyc tracking</code> 命令来检查 chrony 的工作状态：</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">text</li></ul></figcaption><div class="tabs-content"><figure class="highlight text" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Reference ID    : 50484330 (PHC0)</span><br><span class="line">Stratum         : 3</span><br><span class="line">Ref time (UTC)  : Thu Oct 17 16:26:56 2024</span><br><span class="line">System time     : 0.000000000 seconds fast of NTP time</span><br><span class="line">Last offset     : -0.000001475 seconds</span><br><span class="line">RMS offset      : 0.000000613 seconds</span><br><span class="line">Frequency       : 0.008 ppm slow</span><br><span class="line">Residual freq   : -0.019 ppm</span><br><span class="line">Skew            : 0.064 ppm</span><br><span class="line">Root delay      : 0.000000001 seconds</span><br><span class="line">Root dispersion : 0.000010623 seconds</span><br><span class="line">Update interval : 8.0 seconds</span><br><span class="line">Leap status     : Normal</span><br></pre></td></tr></tbody></table></figure></div></figure><p>主要看第一行 <code>Reference ID</code> 即可：</p><ul><li>如果括号内显示的是 <code>PHCx</code>，说明系统已经配置好了和宿主机的时间同步（部分云厂商会帮你做好这件事），然后你大致就可以关闭本页面了（？</li><li>如果括号内只有域名或者 IP，说明系统只配置了 NTP 同步，继续按照下面的方法配置即可</li><li>当然你可能会直接得到一个 <code>command not found</code>，说明你没有安装 <code>chrony</code>，可以参考下面的命令来安装，不同发行版安装方法不同，以 Debian 为例：    <figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">sh</li></ul></figcaption><div class="tabs-content"><figure class="highlight sh" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install chrony</span><br></pre></td></tr></tbody></table></figure></div></figure>  <div class="alert info"><p>安装 <code>chrony</code> 会自动移除 <code>systemd-timesyncd</code> 和其他时间同步工具</p></div></li></ul><h3 id="检查-PTP-设备"><a href="#检查-PTP-设备" class="headerlink" title="检查 PTP 设备"></a>检查 PTP 设备</h3><p>运行 <code>ls /dev/ptp_* -lah</code> 来检查 VM 里是否已经有 PTP 设备</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">sh</li></ul></figcaption><div class="tabs-content"><figure class="highlight sh" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hyper-V</span></span><br><span class="line">lrwxrwxrwx 1 root root 4 Oct 17 13:17 /dev/ptp_hyperv -&gt; ptp0</span><br><span class="line"><span class="comment"># QEMU/KVM</span></span><br><span class="line">lrwxrwxrwx 1 root root 4 Oct 17 13:50 /dev/ptp_kvm -&gt; ptp0</span><br></pre></td></tr></tbody></table></figure></div></figure><p>如果报错 <code>No such file or directory</code>，尝试载入虚拟机的 PTP 模块</p><ul><li>Hyper-V  <figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">sh</li></ul></figcaption><div class="tabs-content"><figure class="highlight sh" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modprobe hv_utils</span><br><span class="line"><span class="comment"># echo hv_utils &gt;&gt; /etc/modules # Load module on boot</span></span><br></pre></td></tr></tbody></table></figure></div></figure>  （不过理论上正常系统检测到 Hyper-V 应该会自动载入的…真的会有默认不载入的吗</li><li>QEMU&#x2F;KVM  <figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">sh</li></ul></figcaption><div class="tabs-content"><figure class="highlight sh" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modprobe ptp_kvm</span><br><span class="line"><span class="built_in">echo</span> ptp_kvm &gt;&gt; /etc/modules <span class="comment"># Load module on boot</span></span><br></pre></td></tr></tbody></table></figure></div></figure>  （倒是 QEMU 的貌似不会自动载入</li></ul><h3 id="添加时钟源"><a href="#添加时钟源" class="headerlink" title="添加时钟源"></a>添加时钟源</h3><p>PTP 设备出现以后就可以开始配置 <code>chrony</code> 了：</p><p>先编辑 <code>/etc/chrony/chrony.conf</code>，注释掉所有以 <code>pool</code> 和 <code>sourcedir</code> 开始的行，然后添加硬件时钟：  </p><ul><li>Hyper-V  <figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">sh</li></ul></figcaption><div class="tabs-content"><figure class="highlight sh" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"maxupdateskew 100.0</span></span><br><span class="line"><span class="string">refclock PHC /dev/ptp_hyperv poll 3 dpoll -2 offset 0 stratum 2</span></span><br><span class="line"><span class="string">makestep 1.0 -1"</span> &gt; /etc/chrony/conf.d/hv.conf</span><br></pre></td></tr></tbody></table></figure></div></figure></li><li>QEMU&#x2F;KVM  <figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">sh</li></ul></figcaption><div class="tabs-content"><figure class="highlight sh" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"maxupdateskew 100.0</span></span><br><span class="line"><span class="string">refclock PHC /dev/ptp_kvm poll 3 dpoll -2 offset 0 stratum 2</span></span><br><span class="line"><span class="string">makestep 1.0 -1"</span> &gt; /etc/chrony/conf.d/kvm.conf</span><br></pre></td></tr></tbody></table></figure></div></figure></li></ul><h3 id="完成配置"><a href="#完成配置" class="headerlink" title="完成配置"></a>完成配置</h3><p>重启 <code>chrony</code>，查看时间同步信息  </p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">text</li></ul></figcaption><div class="tabs-content"><figure class="highlight text" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart chrony</span><br><span class="line">sleep 30</span><br><span class="line">chronyc tracking</span><br></pre></td></tr></tbody></table></figure></div></figure><p>第一行显示 <code>PHCx</code> 说明已配置完成，可以看到 PTP 时间同步的延迟低至 <code>0.000000001 seconds</code>，大致能比 NTP 高 10 的 5-7 次方  </p><h2 id="Windows-VM"><a href="#Windows-VM" class="headerlink" title="Windows VM"></a>Windows VM</h2><p><em>（待补充）</em></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;虚拟化环境中 VM 的时间同步是很重要的，时间失去同步可能导致诸如 Git、APT、SSL&amp;#x2F;TLS 等很多服务出现异常，而虚拟机的系统时间还容易受到休眠和在线迁移的影响。  &lt;/p&gt;
&lt;p&gt;在生产环境常用的 Hyper-V 和 QEMU&amp;#x2F;KVM 中，如何优雅地使虚拟机的系统时间和外部时间保持同步呢？  &lt;/p&gt;</summary>
    
    
    
    <category term="教程" scheme="https://www.mbrjun.cn/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Hyper-V" scheme="https://www.mbrjun.cn/tags/Hyper-V/"/>
    
    <category term="时间同步" scheme="https://www.mbrjun.cn/tags/%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/"/>
    
    <category term="NTP" scheme="https://www.mbrjun.cn/tags/NTP/"/>
    
    <category term="PTP" scheme="https://www.mbrjun.cn/tags/PTP/"/>
    
    <category term="KVM" scheme="https://www.mbrjun.cn/tags/KVM/"/>
    
  </entry>
  
  <entry>
    <title>将 Exos 硬盘格式化为 4Kn</title>
    <link href="https://www.mbrjun.cn/archives/498/"/>
    <id>https://www.mbrjun.cn/archives/498/</id>
    <published>2024-08-02T00:00:00.000Z</published>
    <updated>2024-08-02T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Exos 采用高级格式（AF）的硬盘大多默认设置为 512e 模式，写一篇 512e&#x2F;4Kn 模式互相切换的教程  </p><span id="more"></span><p>修改之前先确定一下硬盘是否支持 AF（物理扇区大小为 4K 则表示支持），512n 模式的硬盘是没法改的<br>Exos X 系列的氦气盘全部支持 AF，都可以改  </p><p><img src="https://cos.mbrjun.cn/IMGS/2024/08/02/85059b01-0ae4-4d68-a536-3a954637b3f4.webp" alt="512e format"></p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li><a href="https://www.seagate.com/cn/zh/support/software/seachest/">Seachest Lite</a></li></ul><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>安装好工具之后，命令行打开工具目录（Linux 的话貌似不需要这一步）  </p><p>然后输入命令扫描磁盘</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">Windows</li><li class="tab">Linux</li></ul></figcaption><div class="tabs-content"><figure class="highlight plaintext" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./SeaChest_Lite_x64_windows.exe --scan</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext" style="display: none;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SeaChest_Lite --scan</span><br></pre></td></tr></tbody></table></figure></div></figure><p><img src="https://cos.mbrjun.cn/IMGS/2024/08/02/ccd2d193-a6fc-42f6-9c84-76bae7b75aa9.webp" alt="SeaChest Disk List"></p><p>找到你要操作的磁盘的编号，比如 PD2</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">Windows</li><li class="tab">Linux</li></ul></figcaption><div class="tabs-content"><figure class="highlight plaintext" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./SeaChest_Lite_x64_windows.exe --device PDx --setSectorSize 4096</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext" style="display: none;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SeaChest_Lite --device PDx --setSectorSize 4096</span><br></pre></td></tr></tbody></table></figure></div></figure><p><code>PDx</code> 替换为上面的磁盘编号，<code>--setSectorSize</code> 后面跟上你想设置的扇区大小<br>Exos SATA 盘可以设置的扇区大小有 512 和 4096，SAS 盘额外还可以设置成 4160 和 4224  </p><p>如果上面的命令没有报错的话，就可以确认格式化了  </p><div class="alert warning"><p>确认操作后，磁盘内所有扇区的数据都会被清除，不要忘记数据备份</p></div><div class="alert warning"><p>请确保你的主板&#x2F;固件支持你设置的扇区大小，否则可能导致硬盘无法读取或电脑无法开机</p></div><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">Windows</li><li class="tab">Linux</li></ul></figcaption><div class="tabs-content"><figure class="highlight plaintext" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./SeaChest_Lite_x64_windows.exe --device PDx --setSectorSize 4096 --confirm this-will-erase-data-and-may-render-the-drive-inoperable</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext" style="display: none;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SeaChest_Lite --device PDx --setSectorSize 4096 --confirm this-will-erase-data-and-may-render-the-drive-inoperable</span><br></pre></td></tr></tbody></table></figure></div></figure><p><img src="https://cos.mbrjun.cn/IMGS/2024/08/02/e0119ffe-5942-4cf9-aa35-d1f0f9ebe9ea.webp" alt="SeaChest Fast Format"></p><p>新盘一般两分钟就能跑完，有些老型号可能需要跑很久  </p><p><img src="https://cos.mbrjun.cn/IMGS/2024/08/02/d4fc8077-12ba-4102-a9d3-b015ba518949.webp" alt="4Kn Format"></p><p>重新获取一下硬盘信息就可以看到新的扇区大小了w</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Exos 采用高级格式（AF）的硬盘大多默认设置为 512e 模式，写一篇 512e&amp;#x2F;4Kn 模式互相切换的教程  &lt;/p&gt;</summary>
    
    
    
    <category term="教程" scheme="https://www.mbrjun.cn/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="希捷" scheme="https://www.mbrjun.cn/tags/%E5%B8%8C%E6%8D%B7/"/>
    
    <category term="Exos" scheme="https://www.mbrjun.cn/tags/Exos/"/>
    
    <category term="机械硬盘" scheme="https://www.mbrjun.cn/tags/%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98/"/>
    
    <category term="HDD" scheme="https://www.mbrjun.cn/tags/HDD/"/>
    
  </entry>
  
  <entry>
    <title>将 Debian 的根目录 FS 切换为 ZFS</title>
    <link href="https://www.mbrjun.cn/archives/497/"/>
    <id>https://www.mbrjun.cn/archives/497/</id>
    <published>2024-05-18T00:00:00.000Z</published>
    <updated>2024-05-18T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 更换根目录的 FS 为 ZFS 是可行的，写一篇教程记录下大致步骤和可能出现的问题  </p><span id="more"></span><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>不比系统盘小的一块空硬盘</li></ul><h2 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h2><h3 id="1-ZFS-驱动和工具"><a href="#1-ZFS-驱动和工具" class="headerlink" title="1 - ZFS 驱动和工具"></a>1 - ZFS 驱动和工具</h3><p>Debian 目前默认的内核并没有集成 ZFS 驱动，必须更换内核或者手动安装内核模块才能正常使用 ZFS  </p><p><strong>方法一</strong></p><p>这里可以直接安装 <code>proxmox-ve</code> 包，Proxmox VE 自带了 ZFS 的管理工具和驱动（驱动由 Proxmox VE 的定制内核提供）， 且 PVE 对 ZFS 的支持也非常全： </p><div class="alert info"><p>如果你安装了 qemu，此方法会将你的 qemu 替换为 PVE 修改后的版本</p></div><div class="alert info"><p>如果你使用 systemd-timesyncd 用于时间同步，此方法会将你的 systemd-timesyncd 替换为 chrony</p></div><div class="alert warning"><p>下面的安装命令仅适用于 Debian 12 Bookworm AMD64，其他 Debian 版本或其他架构无法使用</p></div><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb [arch=amd64] http://download.proxmox.com/debian/pve bookworm pve-no-subscription&quot;</span> &gt; /etc/apt/sources.list.d/pve-install-repo.list<br>wget https://enterprise.proxmox.com/debian/proxmox-release-bookworm.gpg -O /etc/apt/trusted.gpg.d/proxmox-release-bookworm.gpg <br>apt update<br>apt install proxmox-default-kernel proxmox-ve postfix open-iscsi chrony -y<br>apt remove linux-image-amd64 <span class="hljs-string">&#x27;linux-image-6.1*&#x27;</span> -y<br>update-grub<br>systemctl reboot<br></code></pre></td></tr></table></figure><p>如果只使用 Proxmox VE 的 ZFS 管理工具和驱动，不使用 Proxmox VE 虚拟机，可以考虑把 <code>proxmox-ve</code> 卸载掉：<code>apt remove proxmox-ve -y</code></p><p><strong>方法二</strong></p><p>使用原有内核，不安装 <code>proxmox-ve</code> 或其他内核，使用 dkms 手动安装 ZFS 驱动</p><div class="alert warning"><p>此方法可能无法在启用了 UEFI 安全启动的设备上正常工作，原因如下：  </p><p>Linux 5.4 中添加了 <code>kernel_lockdown</code> 功能，在启用 UEFI 安全启动的设备上，<code>kernel_lockdown</code> 强制启用，此功能只能在内核编译时去掉  </p><p><code>kernel_lockdown</code> 会阻止系统载入未签名的自定义模块，<code>zfs-dkms</code> 就是未签名的模块  </p><p><strong>您必须为内核和 dkms 配置自定义签名才能在启用了 UEFI 安全启动的设备上使用此方法</strong>（流程非常复杂，可能还需要在 UEFI 固件设置里手动导入证书，能单独再写一篇文章了）</p></div><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">apt install linux-headers-amd64 zfsutils-linux zfs-dkms<br>modprobe zfs<br></code></pre></td></tr></table></figure><h3 id="2-复制磁盘数据"><a href="#2-复制磁盘数据" class="headerlink" title="2 - 复制磁盘数据"></a>2 - 复制磁盘数据</h3><p>假设原硬盘的分区结构如下：  </p><table>    <tr>        <td colspan="2"><b>vda</b></td>    <tr>    <tr>        <td><b>1</b></td>        <td><b>2</b></td>        <td><b>3</b></td>        <td></td>    <tr>    <tr>        <td>BIOS Boot</td>        <td>Linux filesystem</td>        <td>Linux LVM</td>        <td></td>    <tr>    <tr>        <td></td>        <td><b>ext4 /boot</b></td>        <td><b>VG system</b></td>        <td></td>    <tr>    <tr>        <td></td>        <td></td>        <td><b>root</b></td>        <td><b>swap</b></td>    <tr>    <tr>        <td></td>        <td></td>        <td>btrfs /</td>        <td>swap</td>    <tr></table><p>先把系统盘（以 vda 为例）复制到另一块盘 vdb，然后清除掉 vdb 上的 boot 和 root 分区</p><div class="alert info"><p>如果你的系统盘上有 LVM，你需要在磁盘克隆后使用 <code>vgimportclone</code> 重新生成 LVM 的 UUID，命令已在下方给出</p></div><div class="alert info"><p>UEFI 用户需要两个分区用于启动，一个是 ESP（应挂载到 &#x2F;boot&#x2F;efi），另一个是 ZFS 启动分区（应挂载到 &#x2F;boot），我只以传统引导演示，因为我不使用 UEFI 也没有 ESP（</p></div><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">vgrename system systemOld<br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/vda of=/dev/vdb bs=1M status=progress<br>vgimportclone /dev/vdb3 -n system <span class="hljs-comment"># regen LVM uuids</span><br>wipefs -a /dev/vdb2<br>wipefs -a /dev/system/root<br></code></pre></td></tr></table></figure><p>完成后磁盘分区结构大致是：  </p><table>    <tr>        <td colspan="2"><b>vdb</b></td>    <tr>    <tr>        <td><b>1</b></td>        <td><b>2</b></td>        <td><b>3</b></td>        <td></td>    <tr>    <tr>        <td>BIOS Boot</td>        <td>Linux filesystem</td>        <td>Linux LVM</td>        <td></td>    <tr>    <tr>        <td></td>        <td></td>        <td><b>VG system</b></td>        <td></td>    <tr>    <tr>        <td></td>        <td></td>        <td><b>root</b></td>        <td><b>swap</b></td>    <tr>    <tr>        <td></td>        <td></td>        <td></td>        <td>swap</td>    <tr></table><h3 id="3-创建-ZFS"><a href="#3-创建-ZFS" class="headerlink" title="3 - 创建 ZFS"></a>3 - 创建 ZFS</h3><p>bpool，用于引导：  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sh">zpool create \<br>    -f \<br>    -o cachefile= \<br>    -o ashift=12 -d \<br>    -o feature@async_destroy=enabled \<br>    -o feature@bookmarks=enabled \<br>    -o feature@embedded_data=enabled \<br>    -o feature@empty_bpobj=enabled \<br>    -o feature@enabled_txg=enabled \<br>    -o feature@extensible_dataset=enabled \<br>    -o feature@filesystem_limits=enabled \<br>    -o feature@hole_birth=enabled \<br>    -o feature@large_blocks=enabled \<br>    -o feature@livelist=enabled \<br>    -o feature@lz4_compress=enabled \<br>    -o feature@spacemap_histogram=enabled \<br>    -o feature@zpool_checkpoint=enabled \<br>    -O acltype=posixacl -O canmount=off -O compression=lz4 \<br>    -O devices=off -O normalization=formD -O relatime=on -O xattr=sa \<br>    -O mountpoint=/boot -R /mnt \<br>    bpool \<br>    /dev/vdb2<br></code></pre></td></tr></table></figure><p>rpool，存储 rootfs：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">zpool create \<br>    -f \<br>    -o ashift=12 \<br>    -O acltype=posixacl -O canmount=off -O compression=lz4 \<br>    -O normalization=formD -O relatime=on \<br>    -O xattr=sa -O mountpoint=/ -R /mnt \<br>    rpool \<br>    /dev/system/root<br></code></pre></td></tr></table></figure><p>创建数据集：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">zfs create -o canmount=noauto -o mountpoint=/ rpool/ROOT/proxmox<br>zfs mount rpool/ROOT/proxmox<br>zfs create -o mountpoint=/boot bpool/BOOT/proxmox<br></code></pre></td></tr></table></figure><p>上面的操作完成后磁盘分区结构大致是：  </p><table>    <tr>        <td colspan="2"><b>vdb</b></td>    <tr>    <tr>        <td><b>1</b></td>        <td><b>2</b></td>        <td><b>3</b></td>        <td></td>    <tr>    <tr>        <td>BIOS Boot</td>        <td>Linux filesystem</td>        <td>Linux LVM</td>        <td></td>    <tr>    <tr>        <td></td>        <td><b>zpool bpool</b></td>        <td><b>VG system</b></td>        <td></td>    <tr>    <tr>        <td></td>        <td><b>BOOT</b></td>        <td><b>zpool rpool</b></td>        <td><b>swap</b></td>    <tr>    <tr>        <td></td>        <td>zfs /boot</td>        <td><b>ROOT</b></td>        <td>swap</td>    <tr>    <tr>        <td></td>        <td></td>        <td>zfs /</td>        <td></td>    <tr></table><h3 id="4-拷贝文件"><a href="#4-拷贝文件" class="headerlink" title="4 - 拷贝文件"></a>4 - 拷贝文件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">apt install rsync -y<br>rsync -axHAWXS --numeric-ids --info=progress2 / /mnt<br>rsync -axHAWXS --numeric-ids --info=progress2 /boot /mnt<br></code></pre></td></tr></table></figure><h3 id="5-更新引导"><a href="#5-更新引导" class="headerlink" title="5 - 更新引导"></a>5 - 更新引导</h3><p>在 vdb 创建新的引导文件：  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">mount --rbind /proc /mnt/proc<br>mount --rbind /sys /mnt/sys<br>mount --rbind /dev /mnt/dev<br><span class="hljs-built_in">chroot</span> /mnt<br>apt install zfs-initramfs -y<br>update-initramfs -c -k all<br>grub-install /dev/vdb<br>update-grub<br></code></pre></td></tr></table></figure><h3 id="6-更新-fstab"><a href="#6-更新-fstab" class="headerlink" title="6 - 更新 fstab"></a>6 - 更新 fstab</h3><p>ZFS 不依赖 fstab 挂载，挂载信息存储在文件系统中，自行清理 fstab 的无用条目</p><h3 id="7-导出-ZFS"><a href="#7-导出-ZFS" class="headerlink" title="7 - 导出 ZFS"></a>7 - 导出 ZFS</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">exit</span> <span class="hljs-comment"># quit chroot</span><br>mount | grep -v zfs | <span class="hljs-built_in">tac</span> | awk <span class="hljs-string">&#x27;/\/mnt/ &#123;print $3&#125;&#x27;</span> | \<br>    xargs -i&#123;&#125; umount -lf &#123;&#125;<br>zpool <span class="hljs-built_in">export</span> -a<br></code></pre></td></tr></table></figure><h3 id="8-将-ZFS-写回原系统盘"><a href="#8-将-ZFS-写回原系统盘" class="headerlink" title="8 - 将 ZFS 写回原系统盘"></a>8 - 将 ZFS 写回原系统盘</h3><p><strong>方法一</strong></p><p>如果有 LiveCD，直接进 LiveCD 执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/vdb of=/dev/vda status=progress<br></code></pre></td></tr></table></figure><p><strong>方法二</strong></p><p>如果没有 LiveCD，则将根目录系统挂载为只读，然后再复制：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">mount -o remount,ro / <span class="hljs-comment"># soft remount ro</span><br><span class="hljs-built_in">echo</span> u &gt; /proc/sysrq-trigger <span class="hljs-comment"># force remount ro, not work in btrfs</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/vdb of=/dev/vda status=progress<br></code></pre></td></tr></table></figure><h3 id="9-启动新的系统"><a href="#9-启动新的系统" class="headerlink" title="9 - 启动新的系统"></a>9 - 启动新的系统</h3><p>卸载原有硬盘，重启即可，最终效果如下  </p><p><img src="https://cos.mbrjun.cn/IMGS/2024/05/18/80753f54-2a33-4adf-b11b-c4ef865757b0.webp" alt="ZFS installed"></p><h2 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h2><h3 id="A-initramfs-无法加载-ZFS-驱动"><a href="#A-initramfs-无法加载-ZFS-驱动" class="headerlink" title="A - initramfs 无法加载 ZFS 驱动"></a>A - initramfs 无法加载 ZFS 驱动</h3><ul><li>症状：出现 <code>Failed to load the ZFS Module.</code> 提示</li><li>原因：未正确对模块进行签名，UEFI 安全启动策略不允许载入</li></ul><h3 id="B-initramfs-未找到-zpool"><a href="#B-initramfs-未找到-zpool" class="headerlink" title="B - initramfs 未找到 zpool"></a>B - initramfs 未找到 zpool</h3><ul><li>症状：开机时卡在 <code>Begin: Running /scripts/local-block … done</code> 很久</li><li>症状：出现 <code>ZFS Boot failing in initramfs : Alert! ZFS=rpool/ROOT/proxmox does not exists</code> 类似提示</li><li>原因：initramfs 中没有 zfs 工具，或 zpool 无法被安全导入，请确认第 5 步的 <code>zfs-initramfs</code> 是否正确安装、第 7 步是否成功导出</li><li>解决方案：尝试运行 <code>zpool import -f bpool rpool &amp;&amp; exit</code>，如果出现 <code>command not found</code>，说明 <code>zfs-initramfs</code> 未正确安装，请重新执行全部步骤</li></ul><h3 id="C-ZFS-根目录无法卸载"><a href="#C-ZFS-根目录无法卸载" class="headerlink" title="C - ZFS 根目录无法卸载"></a>C - ZFS 根目录无法卸载</h3><ul><li>症状：完成第 7 步时出现 <code>cannot unmount &#39;/mnt&#39;: pool or dataset is busy</code></li><li>原因：第 3 步完成后，ZFS 所在的磁盘路径发生变化，或者有其他程序占用</li><li>解决方法：如果更改了磁盘路径，需要先修改回来，然后检查是否有程序占用，如果有，请关闭，完成后重新尝试第 7 步，若仍然失败，请重启系统</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://pve.proxmox.com/wiki/Install_Proxmox_VE_on_Debian_12_Bookworm">Install Proxmox VE on Debian 12 Bookworm (pve.proxmox.com)</a></li><li><a href="https://github.com/linux-surface/linux-surface/issues/942">Please, I need Help. Reboot and Stuck on “initramfs” command line (Failed to load the ZFS Module) . (github.com)</a></li><li><a href="https://wiki.archlinux.org/title/Install_Arch_Linux_on_ZFS#Installation">Install Arch Linux on ZFS (wiki.archlinux.org)</a></li><li><a href="https://superuser.com/questions/307541/copy-entire-file-system-hierarchy-from-one-drive-to-another">Copy entire file system hierarchy from one drive to another (superuser.com)</a></li><li><a href="https://lala.im/8318.html">Hetzner独服安装Debian11并将ZFS作为根文件系统 (lala.im)</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Linux 更换根目录的 FS 为 ZFS 是可行的，写一篇教程记录下大致步骤和可能出现的问题  &lt;/p&gt;</summary>
    
    
    
    <category term="教程" scheme="https://www.mbrjun.cn/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://www.mbrjun.cn/tags/Linux/"/>
    
    <category term="ZFS" scheme="https://www.mbrjun.cn/tags/ZFS/"/>
    
  </entry>
  
  <entry>
    <title>针对 LUKS 自动解锁的冷启动攻击</title>
    <link href="https://www.mbrjun.cn/archives/496/"/>
    <id>https://www.mbrjun.cn/archives/496/</id>
    <published>2024-03-31T00:00:00.000Z</published>
    <updated>2024-03-31T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于系统卷全盘加密（FDE），任何不将分区解锁密钥存储在硬件安全设备（如 TPM）的自动解锁方法都不应认为是安全的  </p><p>即使使用硬件安全设备，仍需要额外保护（如 TPM PIN）和内存加密才能保证基本安全  </p><span id="more"></span><p>笔者之前见过一个 Linux 发行版，为了限制用户权限，系统安装时会自动将分区加密，防止用户修改系统文件，此加密使用 LUKS，解锁密钥在 <code>grub-install</code> 的过程中写入磁盘，开机时使用磁盘中的密钥自动解锁，如前面两段话所说，这种加密方法并不安全，“防君子不防小人”，可以直接从内存中提取密钥（因为开机后，系统若要正常运行，必须将 AES 密钥载入内存），这种从内存中提取密钥的破解方法被称为“冷启动攻击”  </p><div class="alert warning"><p>此文章仅展示 LUKS 自动解锁时可能存在的安全问题，其他磁盘加密机制如 BitLocker 也存在此问题，<strong>请不要将此教程用于违法用途</strong>  </p><p>若要保证数据安全，请配置 TPM PIN 或其他预验证机制，并启用内存加密。这可以有效防止冷启动攻击  </p><p>其中，内存加密可以防止攻击者读取你的内存获取明文密钥，预验证机制则在密钥写入内存前要求验证，防止攻击者将硬盘拆下，安装至其他计算机进行攻击  </p></div><p>因为这种加密的自动解锁方式安全性几乎为 0，所以写一篇破解教程进行演示  </p><div class="alert info"><p><strong>什么是冷启动攻击？</strong><br>冷启动攻击（cold boot attack）是在攻击者使用冷启动重新启动计算机后，通过技术手段转储内存，从内存中提取密钥或其他敏感信息</p></div><p>本教程演示的操作全部在本地搭建的 KVM 虚拟机完成，对于虚拟机来说，攻击成本极低，而对于实体机，攻击则需要准备液氮（用于冷却内存，防止数据快速丢失）和专用读取器  </p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>Linux 机器做为宿主机</li><li>配置了 LUKS 的虚拟机，且开机时 grub 会在磁盘中读取密钥进行解密</li></ul><h2 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h2><h3 id="1-安装操作系统"><a href="#1-安装操作系统" class="headerlink" title="1 - 安装操作系统"></a>1 - 安装操作系统</h3><p>创建虚拟机并安装操作系统，这个操作就不讲了，本文直接使用上面提到的“为了限制用户权限”的发行版演示，敏感内容均已打码  </p><p><img src="https://cos.mbrjun.cn/IMGS/2024/03/31/93aa31a6-4e26-41a5-b88e-a90f80eddd2d.webp" alt="Proxmox VE create VM"></p><h3 id="2-分析分区结构"><a href="#2-分析分区结构" class="headerlink" title="2 - 分析分区结构"></a>2 - 分析分区结构</h3><p>操作系统安装完成后，使用工具 cfdisk 查看磁盘分区表： </p><p><img src="https://cos.mbrjun.cn/IMGS/2024/03/31/e7946926-8cf1-41b2-bcc9-87f5bb279f0c.webp" alt="cfdisk"></p><p>可以看到大致分区结构如下： </p><ul><li>前 32768 个扇区（16 MiB）保留</li><li>一个 vfat EFI 分区，存储 Grub EFI 文件  </li><li>一个 ext4 启动分区，存储 Grub 文件和操作系统内核  </li><li>一个 LUKS 加密卷</li></ul><p>在未加密的启动分区可以找到 <code>grub.cfg</code>，打开后确认是开机时自动解密系统分区，且未直接将解锁密钥存储在配置文件中  </p><p><img src="https://cos.mbrjun.cn/IMGS/2024/03/31/8140fc65-8719-4533-b2e9-ae793ab10c3a.webp" alt="Grub menuentry"></p><p>Grub 在启动时已经自动解锁系统分区，启动系统过程中，Grub 会将加密系统卷的 UUID（红线）、加密系统卷的密钥路径（黄线）和内核所在分区的 UUID（绿线）传递给内核，以便在 initrd 中正常解锁  </p><div class="alert info"><p>如果 Grub 没有配置密码，或者你可以更改 Grub 配置文件删除密码，你可以直接在 Grub Shell 中使用 <code>cat</code> 命令跟上密钥路径获取密钥  </p><p>但如果 Grub 设置了密码，同时引导分区加密，将无法使用此方法，只能使用冷启动攻击。冷启动攻击是一种通用的攻击方法  </p></div><h3 id="3-转储内存"><a href="#3-转储内存" class="headerlink" title="3 - 转储内存"></a>3 - 转储内存</h3><p>使用正常方法开机（此步骤被称为冷启动，这也是冷启动攻击一词的由来）  </p><p>等待操作系统完成磁盘解密后（出现登录屏幕），执行下面的操作：</p><ul><li><strong>对于虚拟机：</strong><br>  在宿主机上，休眠该虚拟机，创建的休眠文件包含内存转储</li><li><strong>对于物理机：</strong><br>  使用液氮冷却剂为内存冷却，将内存拆下并安装到硬件转储器，创建内存转储</li></ul><div class="alert info"><p>建议使用允许系统正常启动的最小内存，大多数情况 4 GiB 是足够的，大内存可能会导致转储文件很大  </p><p>正常情况下，转储文件的大小最大为内存大小的 3 倍，请保留充足的磁盘空间</p></div><p>Proxmox VE 默认配置中创建的休眠文件是一个 LVM 卷，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Disk /dev/mapper/pve-vm--299--state--suspend--2024--03--31: 8.49 GiB, 9114222592 bytes, 17801216 sectors<br>Units: sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 65536 bytes / 65536 bytes<br></code></pre></td></tr></table></figure><p>我们可以使用命令将 LVM 卷转换为文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/mapper/pve-vm--299--state--suspend--2024--03--31 of=MEMORY.dmp<br></code></pre></td></tr></table></figure><h3 id="4-提取-AES-密钥"><a href="#4-提取-AES-密钥" class="headerlink" title="4 - 提取 AES 密钥"></a>4 - 提取 AES 密钥</h3><p>安装 <code>findaes</code> 工具，然后使用下面的命令提取转储文件中的 AES 密钥：  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">findaes MEMORY.dmp<br></code></pre></td></tr></table></figure><p>输出类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Searching MEMORY.dmp<br>Found AES-128 key schedule at offset 0x1bab8a9:<br>85 f1 dd c6 ea 68 09 6c d9 8d e8 39 65 8c 61 70<br>Found AES-128 key schedule at offset 0x1baba99:<br>a3 9e cb 7d 01 b3 fb 9e 4e 1a e0 a4 ec a3 7e a8<br>Found AES-128 key schedule at offset 0x129589f8:<br>b7 40 59 a2 0c c0 2e a3 0c 89 71 a3 16 ff 20 66<br>Found AES-256 key schedule at offset 0x1b564786:<br>ae 66 77 dd e6 e6 10 3c b5 f6 a2 a0 56 1a b1 df 41 f0 ce c3 d7 5b 4c ef c3 4a eb a7 e6 e8 2d 1e<br></code></pre></td></tr></table></figure><p>如果有两个连续的 AES-128 密钥，请拼接为 AES-256 密钥（地址靠后的 + 地址靠前的），例如上面输出中 <code>0x1baba99</code> 和 <code>0x1bab8a9</code> 地址连续，拼接为 <code>a3 9e cb 7d 01 b3 fb 9e 4e 1a e0 a4 ec a3 7e a8 85 f1 dd c6 ea 68 09 6c d9 8d e8 39 65 8c 61 70</code><br>同样的，如果有四个连续的 AES-128 或两个连续的 AES-256，则拼接为 AES-512  </p><p>然后将所有提取到的密钥整理一下，去掉空格，从上面的输出我们就得到了这三个密钥：</p><ul><li>AES-128 <code>b74059a20cc02ea30c8971a316ff2066</code></li><li>AES-256 <code>a39ecb7d01b3fb9e4e1ae0a4eca37ea885f1ddc6ea68096cd98de839658c6170</code>（由两个 AES-128 拼接）</li><li>AES-256 <code>ae6677dde6e6103cb5f6a2a0561ab1df41f0cec3d75b4cefc34aeba7e6e82d1e</code></li></ul><h3 id="5-解密卷"><a href="#5-解密卷" class="headerlink" title="5 - 解密卷"></a>5 - 解密卷</h3><p>将密钥转换为二进制写入文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> a39ecb7d01b3fb9e4e1ae0a4eca37ea885f1ddc6ea68096cd98de839658c6170 | xxd -r -p &gt; key.txt<br></code></pre></td></tr></table></figure><p>然后尝试使用 AES 密钥为加密卷添加密码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">cryptsetup luksAddKey /dev/vda3 --master-key-file key.txt<br></code></pre></td></tr></table></figure><p>如果提示 <em>Enter new passphrase for key slot:</em> ，则此 AES 密钥与分区解密密钥对应，继续设置密码即可  </p><p>如果密钥错误，则提示 <em>Volume key does not match the volume.</em> ，此时需要继续尝试其他密钥，直到解密成功  </p><p>如果有多个分区，则为每个分区尝试上面的步骤  </p><h3 id="6-挂载"><a href="#6-挂载" class="headerlink" title="6 - 挂载"></a>6 - 挂载</h3><p>密码设置完成后，我们就可以直接使用密码解密 LUKS 卷并挂载，理论上此方法也完全适用于 BitLocker，但是笔者并未进行测试  </p><div class="alert info"><p>做好了对冷启动攻击的防护也不能保证数据绝对安全，因为除了冷启动攻击，针对磁盘加密还有许多其他类型攻击，比如 DMA 攻击，通常是将计算机的网卡或其他硬件更换为特殊读取器进行攻击，部分操作系统现在已经默认开启 DMA 攻击的内核防护  </p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于系统卷全盘加密（FDE），任何不将分区解锁密钥存储在硬件安全设备（如 TPM）的自动解锁方法都不应认为是安全的  &lt;/p&gt;
&lt;p&gt;即使使用硬件安全设备，仍需要额外保护（如 TPM PIN）和内存加密才能保证基本安全  &lt;/p&gt;</summary>
    
    
    
    <category term="安全" scheme="https://www.mbrjun.cn/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="LUKS" scheme="https://www.mbrjun.cn/tags/LUKS/"/>
    
    <category term="BitLocker" scheme="https://www.mbrjun.cn/tags/BitLocker/"/>
    
    <category term="冷启动攻击" scheme="https://www.mbrjun.cn/tags/%E5%86%B7%E5%90%AF%E5%8A%A8%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>2024 来啦！</title>
    <link href="https://www.mbrjun.cn/archives/495/"/>
    <id>https://www.mbrjun.cn/archives/495/</id>
    <published>2024-01-01T00:00:00.000Z</published>
    <updated>2024-01-01T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>2024 了喵？2024 了喵！2024 了喵！  </p><span id="more"></span><p><del>唉，咱是废物，我 new post 我都不知道要写啥，看<a href="https://blog.chyk.ink/2023/12/23/my-2023-summary/">其他大佬写的年终总结</a>感觉好厉害，那就 <code>rm -rf brain</code> 然后瞎√8写吧</del>  </p><p><strong>现在是 2024 的第一天，想先吐槽一下，现在能明显感觉到互联网性能下降，这个时候上网的人好多的样子，那就写写咱 2023 最后一天做了点什么吧（</strong>  </p><h2 id="Hexo-更新"><a href="#Hexo-更新" class="headerlink" title="Hexo 更新"></a>Hexo 更新</h2><p>该折腾的折腾了一下，更新 Hexo 大版本到 7：  </p><p><img src="https://cos.mbrjun.cn/IMGS/2024/01/01/06ab9b37-fd79-44fb-bec3-aeb51541973f.webp" alt="Upgrade Hexo 7"></p><h2 id="Home-Assistant-更新"><a href="#Home-Assistant-更新" class="headerlink" title="Home Assistant 更新"></a>Home Assistant 更新</h2><p>本来是想更新的，但是收到了新年的<del>第一份</del>礼物（不是  </p><p><img src="https://cos.mbrjun.cn/IMGS/2024/01/01/623bbf53-444d-4627-8805-4db650f9d9e7.webp" alt="High Packet Loss"></p><p>嗯，那就修好了再搞  </p><hr><p><strong>再看看整个 2023 做了什么喵</strong>  </p><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p><img src="https://cos.mbrjun.cn/IMGS/2024/01/01/5383b7d4-9579-4454-8d7f-d3fea2fab846.webp" alt="GitHub Commits 2023"></p><p>瓷砖贴的还可以？或者说有点不太均匀  </p><p>要不要立一个 1000 commits in 2024 的目标呢？  </p><h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><p>是整的 <code>1.00 PB</code> w   </p><p><img src="https://cos.mbrjun.cn/IMGS/2024/01/01/dbe31304-a6d0-41ed-bf95-de875cc630c0.webp" alt="1PB traffic in 2023"></p><h2 id="使用的新语言"><a href="#使用的新语言" class="headerlink" title="使用的新语言"></a>使用的新语言</h2><p>嗯，好像只有 TypeScript 喵？  </p><h2 id="乌蒙地插"><a href="#乌蒙地插" class="headerlink" title="乌蒙地插"></a>乌蒙地插</h2><p>街机原神，据说入坑可能导致 21 号染色体数量增加  </p><p>4 月入坑（大概），国服打了 32 PC，不过开学就没时间打了，据说现在经常断网，我也没见过  </p><hr><p><strong>还能再写点什么吗（</strong>  </p><h2 id="高中生活第一集"><a href="#高中生活第一集" class="headerlink" title="高中生活第一集"></a>高中生活第一集</h2><p>基本没问题：  </p><p>每天早晨 6 点起床，95% 的时候都能准时到学校（7:30 之前到），但是下暴雪的那天（2023-12-14，天津天气为暴风雪），也就是“北京地铁发生追尾事故导致 102 人骨折”的那天，交通状况十分差，从出校门到家就用了 130 分钟，路面积雪和道路结冰导致自行车和电动车不可使用。至于打车？这个鬼天气几个小时都打不到的，那就要走到地铁站（不到两公里，用了 30 分钟），坐地铁，然后再走回家（用了一个小时）  </p><p><img src="https://cos.mbrjun.cn/IMGS/2024/01/01/c1976387-4414-428b-9e88-f473c40d9fe7.webp" alt="地铁大学城站，2023-12-14 晚"></p><p>感觉管的不算太严，尤其是初中部，中午完全没有老师管，以至于出现一整个班都在玩手机的情况（甚至有人带了平板），还有人在智能白板打游戏（是什么呢？乌蒙地插）  </p><p>我写这些东西，不说具体是谁在哪，应该不会有人找到我让我删除内容吧（  </p><p>和初中部比起来，高中部确实安静不少，不过我这个性格，一个学期要过去了，班里认识的人还不到 10 个…  </p><h3 id="语文"><a href="#语文" class="headerlink" title="语文"></a>语文</h3><p>相对摆烂的状态？感觉没啥具体的目标欸，就是在背课文  </p><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><p>还是有点吃力（函数后面），初中数学就不好，现在的目标是能及格  </p><h3 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h3><p>英语老师是班主任，感觉还是有点可怕的  </p><h3 id="物理"><a href="#物理" class="headerlink" title="物理"></a>物理</h3><p>之前连续发烧了一周，感觉理科落下的内容好难跟上，成绩一下子就下去了，变成废物了  </p><p>对了，我们物理老师对实验很热情，书上的所有实验都去实验室，今年似乎做了四次了  </p><h3 id="化学"><a href="#化学" class="headerlink" title="化学"></a>化学</h3><p>似乎没什么好写的，但是我喜欢化学。  </p><p>另外我们的化学老师会把课外班叫做传销  </p><h3 id="生物"><a href="#生物" class="headerlink" title="生物"></a>生物</h3><p>老师讲课很好，理科中听的最明白的，但是一定要吐槽一下这个进度，期末考试之前就剩三节课了，还有一个单元没讲呢（目前讲到了 ATP）  </p><p>据说是因为现在提倡素质教育，音体美课时增加，老师说之前生物课一周都是四节课，还可以去实验室做书上的实验，但现在一周两节课都讲不完  </p><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>作业全是抄书，抄了几十页 B5 纸了，没啥好写的，这是一定不选的科</p><h3 id="政治"><a href="#政治" class="headerlink" title="政治"></a>政治</h3><p>背不下来，也没啥好写的，这是一定不选的科  </p><h3 id="地理"><a href="#地理" class="headerlink" title="地理"></a>地理</h3><p>还不错，地理课睡着了课后补都很容易，目前还算简单  </p><hr><p>真不知道写啥了，那就想写的时候再补上吧，还是比较喜欢写技术文章，今年看看应该会有时间写一个“冷启动攻击和硬盘加密的一些破解手段”  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2024 了喵？2024 了喵！2024 了喵！  &lt;/p&gt;</summary>
    
    
    
    <category term="日常" scheme="https://www.mbrjun.cn/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="2024" scheme="https://www.mbrjun.cn/tags/2024/"/>
    
    <category term="新年" scheme="https://www.mbrjun.cn/tags/%E6%96%B0%E5%B9%B4/"/>
    
    <category term="跨年" scheme="https://www.mbrjun.cn/tags/%E8%B7%A8%E5%B9%B4/"/>
    
  </entry>
  
  <entry>
    <title>解决 Hyper-V 安装 Linux 黑屏</title>
    <link href="https://www.mbrjun.cn/archives/494/"/>
    <id>https://www.mbrjun.cn/archives/494/</id>
    <published>2023-08-20T00:00:00.000Z</published>
    <updated>2023-08-20T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hyper-V 黑屏或者卡在 Loading initial ramdisk 的可以来参考下  </p><blockquote><p>“你们这是什么间接分支跟踪技术（IBT）啊，你们这是害人不浅啊你们这个技术.<br>麻烦你们，真的太过分了，你们搞这个技术干什么，<br>我游戏本每一种内核，都启动不到那个图形界面呐！你叫我游戏本怎么办啊，它现在连steam都打不开啊好不好<br>你们这是什么技术啊,<br>你们害死我游戏本了.<br>谁是intel 快点出来 再不来我去报警了啊<br>我跟你们说你们这一帮人啊<br>一天到晚乱改，是不是人啊，你们一天到晚乱改”</p></blockquote><span id="more"></span><hr><p>开机，出现 GRUB 界面时按一下 <code>e</code>，然后在 <code>linux</code> 那一行最后加个 <code>ibt=off</code>  </p><p><img src="https://cos.mbrjun.cn/IMGS/2023/08/26/9e50bfeb-c21a-473e-a31b-9b1084ae9d3f.png" alt="ibtoff"></p><p>然后按 Ctrl+X 退出，即可正常开机，登录后编辑 <code>/etc/default/grub</code>  </p><p><img src="https://cos.mbrjun.cn/IMGS/2023/08/26/77c23130-1144-4adb-9544-fe82bb096584.webp" alt="grub"></p><p>在 <code>GRUB_CMDLINE_LINUX_DEFAULT</code> 引号里加上 <code>ibt=off</code> 保存  </p><p>运行 <code>sudo grub-mkconfig -o /boot/grub/grub.cfg</code> (Debian&#x2F;Ubuntu: <code>sudo update-grub</code>) 即可正常使用  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Hyper-V 黑屏或者卡在 Loading initial ramdisk 的可以来参考下  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“你们这是什么间接分支跟踪技术（IBT）啊，你们这是害人不浅啊你们这个技术.&lt;br&gt;麻烦你们，真的太过分了，你们搞这个技术干什么，&lt;br&gt;我游戏本每一种内核，都启动不到那个图形界面呐！你叫我游戏本怎么办啊，它现在连steam都打不开啊好不好&lt;br&gt;你们这是什么技术啊,&lt;br&gt;你们害死我游戏本了.&lt;br&gt;谁是intel 快点出来 再不来我去报警了啊&lt;br&gt;我跟你们说你们这一帮人啊&lt;br&gt;一天到晚乱改，是不是人啊，你们一天到晚乱改”&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="教程" scheme="https://www.mbrjun.cn/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://www.mbrjun.cn/tags/Linux/"/>
    
    <category term="Hyper-V" scheme="https://www.mbrjun.cn/tags/Hyper-V/"/>
    
  </entry>
  
  <entry>
    <title>为 Hyper-V 上的 Linux VM 配置 3D 加速</title>
    <link href="https://www.mbrjun.cn/archives/493/"/>
    <id>https://www.mbrjun.cn/archives/493/</id>
    <published>2023-08-01T00:00:00.000Z</published>
    <updated>2023-08-01T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>WSL2 默认已经使用了 GPU 半虚拟化（GPU-PV）来进行 3D 加速，GPU-PV 是 RemoteFX 的替代品，但是 GPU-PV 在 Hyper-V 虚拟机启用却比较复杂，Windows 的教程已经有人写了，所以分享下 Hyper-V Linux 虚拟机配置 GPU-PV 的教程  </p><span id="more"></span><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>一个 Hyper-V Linux 虚拟机，内核版本是 5.15 或 6.0 或 6.1，内核头已安装</li><li>一个 WSL 2 虚拟机（提取驱动用，提取后可删除，尽量和 Hyper-V 虚拟机使用相同的操作系统）</li><li>Windows 10 最新版本或 Windows 11，x86&#x2F;x86-64 架构（似乎 ARM 做不到，我没测试）</li></ul><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>我会使用我喜欢的环境进行测试，如果你正在使用相同的环境，应该可以直接照抄我的命令，如果你正在使用其他发行版或其他硬件，操作步骤可能会有差别  </p><ul><li>Windows 11 22H2</li><li>Arch Linux VM，内核：<a href="https://archlinux.org/packages/core/x86_64/linux-lts/">linux-lts</a></li><li>NVIDIA GeForce RTX 4070 Ti</li></ul><h2 id="HV-虚拟机设置"><a href="#HV-虚拟机设置" class="headerlink" title="HV 虚拟机设置"></a>HV 虚拟机设置</h2><h3 id="1-关闭动态内存"><a href="#1-关闭动态内存" class="headerlink" title="1 - 关闭动态内存"></a>1 - 关闭动态内存</h3><p>开启动态内存后，GPU-PV 不能正常工作，所以直接为虚拟机设置足够的内存和 swap 并禁用动态内存，这一步骤应该比较简单<br><img src="https://cos.mbrjun.cn/IMGS/2023/08/26/db886f0e-130b-4ada-bba5-e296e17b66f0.png" alt="Disable dynamic memory hyperv"></p><h3 id="2-添加-GPU-PV-硬件"><a href="#2-添加-GPU-PV-硬件" class="headerlink" title="2 - 添加 GPU-PV 硬件"></a>2 - 添加 GPU-PV 硬件</h3><p>首先确保虚拟机<strong>已关机</strong>，然后按下 Win+X（或右键开始菜单），选择任意一个：  </p><ul><li>命令提示符（管理员）</li><li>PowerShell（管理员）</li><li>终端（管理员）<br><img src="https://cos.mbrjun.cn/IMGS/2023/08/26/810d8ea7-4b55-45d5-adae-cec8c84c70ed.png" alt="terminal admin"></li></ul><p>在弹出的窗口中输入这三行命令，每一行结束后，都请按 Enter 键</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">pwsh</li></ul></figcaption><div class="tabs-content"><figure class="highlight pwsh" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwsh</span><br><span class="line"><span class="built_in">Set-VM</span> <span class="literal">-VMName</span> &lt;vmname&gt; <span class="literal">-GuestControlledCacheTypes</span> <span class="variable">$true</span> <span class="literal">-LowMemoryMappedIoSpace</span> <span class="number">1</span>GB <span class="literal">-HighMemoryMappedIoSpace</span> <span class="number">32</span>GB</span><br><span class="line"><span class="built_in">Add-VMGpuPartitionAdapter</span> <span class="literal">-VMName</span> &lt;vmname&gt;</span><br></pre></td></tr></tbody></table></figure></div></figure><p>其中 <code>&lt;vmname&gt;</code> 替换为你虚拟机的名称。  </p><p>完成此步骤后，打开虚拟机并执行 <code>lspci</code> 命令，检查 GPU-PV 设备是否已经成功安装  </p><p>如果输出中包含 <code>b98b:00:00.0 3D controller: Microsoft Corporation Basic Render Driver</code>，则说明已正确安装设备  </p><h2 id="驱动安装"><a href="#驱动安装" class="headerlink" title="驱动安装"></a>驱动安装</h2><h3 id="3-WSL-驱动"><a href="#3-WSL-驱动" class="headerlink" title="3 - WSL 驱动"></a>3 - WSL 驱动</h3><p>进入 WSL 的终端，运行命令：  </p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">sh</li></ul></figcaption><div class="tabs-content"><figure class="highlight sh" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf - /usr/lib/wsl | zstd -T0 &gt; drivers.tzst</span><br></pre></td></tr></tbody></table></figure></div></figure><p>将 drivers.tzst 拷贝至 Hyper-V 虚拟机根目录（使用任何你喜欢的方式），然后解压：</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">sh</li></ul></figcaption><div class="tabs-content"><figure class="highlight sh" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unzstd drivers.tzst</span><br><span class="line">tar xvf drivers.tar</span><br></pre></td></tr></tbody></table></figure></div></figure><p>然后复制驱动到 &#x2F;lib：</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">sh</li></ul></figcaption><div class="tabs-content"><figure class="highlight sh" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /usr/lib/wsl/lib/* /usr/lib</span><br></pre></td></tr></tbody></table></figure></div></figure><p>如果是 NVIDIA 显卡，还需要额外安装 <code>nvidia-smi</code>：</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">sh</li></ul></figcaption><div class="tabs-content"><figure class="highlight sh" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /usr/lib/wsl/lib/nvidia-smi /usr/bin</span><br></pre></td></tr></tbody></table></figure></div></figure><h3 id="4-安装-DirectX-驱动"><a href="#4-安装-DirectX-驱动" class="headerlink" title="4 - 安装 DirectX 驱动"></a>4 - 安装 DirectX 驱动</h3><p>GPU-PV Linux 使用的 DirectX 驱动名为 <code>dxgkrnl</code>，直接使用 makepkg 进行安装：</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">sh</li></ul></figcaption><div class="tabs-content"><figure class="highlight sh" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/MBRjun/dxgkrnl-dkms-lts</span><br><span class="line"><span class="built_in">cd</span> dxgkrnl-dkms-lts</span><br><span class="line">makepkg -si</span><br><span class="line">modprobe dxgkrnl</span><br></pre></td></tr></tbody></table></figure></div></figure><ul><li><strong>仅适用于 6.0 或 6.1 内核，如果是 5.15 内核，可以直接尝试 <code>yay -Sy dxgkrnl-dkms-git</code> 其他内核你需要自己搬<a href="https://github.com/microsoft/WSL2-Linux-Kernel/">驱动</a></strong></li></ul><h3 id="5-安装-mesa"><a href="#5-安装-mesa" class="headerlink" title="5 - 安装 mesa"></a>5 - 安装 mesa</h3><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">sh</li></ul></figcaption><div class="tabs-content"><figure class="highlight sh" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Sy mesa mesa-utils</span><br></pre></td></tr></tbody></table></figure></div></figure><h3 id="6-检查是否成功安装"><a href="#6-检查是否成功安装" class="headerlink" title="6 - 检查是否成功安装"></a>6 - 检查是否成功安装</h3><p>完成上面五个步骤，<strong>需要先重启系统</strong>  </p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">sh</li></ul></figcaption><div class="tabs-content"><figure class="highlight sh" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /dev/dxg -l</span><br><span class="line">lspci -v</span><br></pre></td></tr></tbody></table></figure></div></figure><p>如果 <code>/dev/dxg</code> 存在，则 DX 驱动已正常安装  </p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">txt</li></ul></figcaption><div class="tabs-content"><figure class="highlight txt" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">crw-rw-rw- 1 root root 10, 119 Aug 26 18:24 /dev/dxg</span><br><span class="line">b98b:00:00.0 3D controller: Microsoft Corporation Basic Render Driver</span><br><span class="line">Physical Slot: 600853645</span><br><span class="line">Flags: bus master, fast devsel, latency 0, NUMA node 0</span><br><span class="line">Capabilities: [40] Null</span><br><span class="line">Kernel driver in use: dxgkrnl</span><br><span class="line">Kernel modules: dxgkrnl</span><br></pre></td></tr></tbody></table></figure></div></figure><h3 id="7-检查-NVIDIA-显卡信息和-CUDA-信息"><a href="#7-检查-NVIDIA-显卡信息和-CUDA-信息" class="headerlink" title="7 - 检查 NVIDIA 显卡信息和 CUDA 信息"></a>7 - 检查 NVIDIA 显卡信息和 CUDA 信息</h3><p>运行 <code>nvidia-smi</code>：  </p><p><img src="https://cos.mbrjun.cn/IMGS/2023/08/26/e59844c1-dba9-43f3-8fa4-af42c07ae3dd.webp" alt="nvidia-smi"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;WSL2 默认已经使用了 GPU 半虚拟化（GPU-PV）来进行 3D 加速，GPU-PV 是 RemoteFX 的替代品，但是 GPU-PV 在 Hyper-V 虚拟机启用却比较复杂，Windows 的教程已经有人写了，所以分享下 Hyper-V Linux 虚拟机配置 GPU-PV 的教程  &lt;/p&gt;</summary>
    
    
    
    <category term="教程" scheme="https://www.mbrjun.cn/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Hyper-V" scheme="https://www.mbrjun.cn/tags/Hyper-V/"/>
    
    <category term="Hypervisor" scheme="https://www.mbrjun.cn/tags/Hypervisor/"/>
    
    <category term="GPU-PV" scheme="https://www.mbrjun.cn/tags/GPU-PV/"/>
    
  </entry>
  
  <entry>
    <title>解决 AIDA64 报错 Hypervisor is present</title>
    <link href="https://www.mbrjun.cn/archives/492/"/>
    <id>https://www.mbrjun.cn/archives/492/</id>
    <published>2023-07-04T00:00:00.000Z</published>
    <updated>2023-07-04T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>解决 AIDA64 测试性能时警告：Hypervisor is present, forcing AIDA64 into a virtualized or sandbox environment. Such enviro nment may affect AIDA64 benchmark results. It is recommended to disable both Hyper-V and Memory Integrity in order to obtain accurate benchmark results.</p><span id="more"></span><p><img src="https://cos.mbrjun.cn/IMGS/2023/08/08/a31d9f0a-1147-4483-80cb-0a239f28943a.png" alt="Hypervisor is present"></p><h2 id="问题出现的原因"><a href="#问题出现的原因" class="headerlink" title="问题出现的原因"></a>问题出现的原因</h2><p>Windows 11 22H2 版本，新安装的 Windows 默认开启了内存完整性，这个功能有助于提高安全性，但是也可能降低性能  </p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>Win+S 输入 gpedit 回车（家庭版需要先<a href="https://zhuanlan.zhihu.com/p/565402268">启用组策略</a>）  </p><p><img src="https://cos.mbrjun.cn/IMGS/2023/08/08/c88839d0-1516-4fc8-8448-21d0f3d44ee9.png" alt="gpedit"></p><p>打开 <strong>计算机配置-管理模板-系统-Device Guard</strong>，找到启用基于虚拟化的安全，双击点开  </p><p><img src="https://cos.mbrjun.cn/IMGS/2023/08/08/3a24d008-a4b6-48bd-9b14-669511b8ca19.png" alt="VBS"></p><p>点击已禁用，保存  </p><p><img src="https://cos.mbrjun.cn/IMGS/2023/08/08/34d6c4b3-f31c-4ea3-8772-4b5680ceecda.png" alt="disable vbs"></p><p>重启电脑即可正常跑分  </p><p><img src="https://cos.mbrjun.cn/IMGS/2023/08/08/3e3f163f-0a87-4e98-8ae1-1c8593c6a47c.png" alt="aida64 ram benchmark"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;解决 AIDA64 测试性能时警告：Hypervisor is present, forcing AIDA64 into a virtualized or sandbox environment. Such enviro nment may affect AIDA64 benchmark results. It is recommended to disable both Hyper-V and Memory Integrity in order to obtain accurate benchmark results.&lt;/p&gt;</summary>
    
    
    
    <category term="软件" scheme="https://www.mbrjun.cn/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
    <category term="Windows" scheme="https://www.mbrjun.cn/tags/Windows/"/>
    
    <category term="AIDA64" scheme="https://www.mbrjun.cn/tags/AIDA64/"/>
    
    <category term="Hypervisor" scheme="https://www.mbrjun.cn/tags/Hypervisor/"/>
    
  </entry>
  
  <entry>
    <title>手动修复 Windows UEFI BCD</title>
    <link href="https://www.mbrjun.cn/archives/491/"/>
    <id>https://www.mbrjun.cn/archives/491/</id>
    <published>2023-07-03T00:00:00.000Z</published>
    <updated>2023-07-03T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单解决使用 DISM 或其他工具释放 Windows 镜像后没有引导项的问题  </p><span id="more"></span><hr><p>看文章前先搞懂这个缩写：</p><ul><li>ESP：EFI system partition，EFI 系统分区，GUID 为 <code>C12A7328-F81F-11D2-BA4B-00A0C93EC93B</code></li></ul><hr><ul><li>首先要确认下你的主板是支持 UEFI 启动的，点进来看这文章的这条应该都符合了  <ul><li>如果你使用 OpenCore <strong>模拟</strong> UEFI，这篇文章有可能不太适合你</li></ul></li><li>然后确认下你要把 BCD 存在哪个 ESP 分区，没有 ESP 分区要创建一个，还要把 BootMgr 补上  <ul><li>这一小段的操作使用任意分区工具都可以  </li><li>一般情况 <code>diskpart.exe</code> 都会显示 ESP 分区类型是 <code>System</code>，少数会是 <code>Primary</code> 或其他类型<br>  <img src="https://cos.mbrjun.cn/IMGS/2023/08/08/33accb46-4dad-4fe5-8d08-c447df3ee370.png" alt="ESP Part">  </li><li>创建的话建议 FAT 或者 FAT32 文件系统，兼容性好，当然如果你的板子支持 NTFS，你可以直接把 (C:) 盘当作 ESP  </li><li>给你的 EFI 分区分配个驱动器号（盘符）或者挂载一下</li></ul></li></ul><p>最后运行下这条命令即可：<br><code>bcdboot C:\Windows /s Z: /f UEFI</code></p><ul><li>C: 是你 Windows 的安装分区（多系统就选你想启动的那个）  </li><li>Z: 是指定 ESP 分区，也就是“你想把 EFI 放到哪个分区”</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单解决使用 DISM 或其他工具释放 Windows 镜像后没有引导项的问题  &lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://www.mbrjun.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Windows" scheme="https://www.mbrjun.cn/tags/Windows/"/>
    
    <category term="UEFI" scheme="https://www.mbrjun.cn/tags/UEFI/"/>
    
    <category term="bootmgr" scheme="https://www.mbrjun.cn/tags/bootmgr/"/>
    
    <category term="bcd" scheme="https://www.mbrjun.cn/tags/bcd/"/>
    
  </entry>
  
  <entry>
    <title>RTL8168 升级使用 PVE 8.0</title>
    <link href="https://www.mbrjun.cn/archives/490/"/>
    <id>https://www.mbrjun.cn/archives/490/</id>
    <published>2023-06-27T16:42:50.000Z</published>
    <updated>2023-06-27T16:42:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>PVE 8.0 使用了新的 Linux 6.2 内核，但该内核版本也会使 RTL8168 网卡无法正常工作，需要降级内核版本才能使用</p><span id="more"></span><blockquote><p>建议大家远离 RTL 8168 网卡，他不仅被 ESXi 7&#x2F;8 所遗忘，如果对面是一个 Intel 的 I225-LM 网卡，更会直接自闭（无法自动协商），现在，他甚至被 <code>pve-kernel-6.2</code> 抛弃  </p></blockquote><p><a href="https://www.mbrjun.cn/archives/489/">先按照常规方法升级</a>，然后确认下你的网卡型号，按下面的步骤降级内核  </p><h2 id="确认网卡型号"><a href="#确认网卡型号" class="headerlink" title="确认网卡型号"></a>确认网卡型号</h2><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">sh</li></ul></figcaption><div class="tabs-content"><figure class="highlight sh" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci | grep Ethernet</span><br></pre></td></tr></tbody></table></figure></div></figure><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">txt</li></ul></figcaption><div class="tabs-content"><figure class="highlight txt" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">02:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller (rev 15)</span><br></pre></td></tr></tbody></table></figure></div></figure><p>如果看到类似这样的输出，有 <code>RTL8111/8168/8411</code> 关键字，那就恭喜中奖，<strong>你正在使用 RTL 8168 网卡！</strong></p><h2 id="降级到-6-1-内核"><a href="#降级到-6-1-内核" class="headerlink" title="降级到 6.1 内核"></a>降级到 6.1 内核</h2><p>其实也不是必须用 6.1，降级到一个你认为稳定的也可以（我是不推荐 5.13 和 6.2），比如 5.15 和 5.19，但是我测试 6.1 是稳定的而且较新的 LTS  </p><p>然后就是注意别装成 Debian 原版内核了，我们要装的是 Proxmox VE 修改的内核</p><p>除了内核本体外还建议装下 kernel header  </p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">sh</li></ul></figcaption><div class="tabs-content"><figure class="highlight sh" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install pve-kernel-6.1 pve-header-6.1</span><br></pre></td></tr></tbody></table></figure></div></figure><p>然后就可以使用自带的 <code>proxmox-boot-tool</code> 调内核优先级了</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">sh</li></ul></figcaption><div class="tabs-content"><figure class="highlight sh" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxmox-boot-tool kernel list</span><br></pre></td></tr></tbody></table></figure></div></figure><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">txt</li></ul></figcaption><div class="tabs-content"><figure class="highlight txt" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Manually selected kernels:</span><br><span class="line">None.</span><br><span class="line"></span><br><span class="line">Automatically selected kernels:</span><br><span class="line">6.1.10-1-pve</span><br><span class="line">6.2.16-3-pve</span><br></pre></td></tr></tbody></table></figure></div></figure><p>将 6.1 内核优先级调最高，以我现在的 6.1.10-1 为例：</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">sh</li></ul></figcaption><div class="tabs-content"><figure class="highlight sh" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxmox-boot-tool kernel pin 6.1.10-1-pve</span><br></pre></td></tr></tbody></table></figure></div></figure><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">txt</li></ul></figcaption><div class="tabs-content"><figure class="highlight txt" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Setting '6.1.10-1-pve' as grub default entry and running update-grub.</span><br><span class="line">Generating grub configuration file ...</span><br><span class="line">Found linux image: /boot/vmlinuz-6.2.16-3-pve</span><br><span class="line">Found initrd image: /boot/initrd.img-6.2.16-3-pve</span><br><span class="line">Found linux image: /boot/vmlinuz-6.1.10-1-pve</span><br><span class="line">Found initrd image: /boot/initrd.img-6.1.10-1-pve</span><br><span class="line">Found memtest86+ 64bit EFI image: /boot/memtest86+x64.efi</span><br><span class="line">Adding boot menu entry for UEFI Firmware Settings ...</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">Manually selected kernels:</span><br><span class="line">None.</span><br><span class="line"></span><br><span class="line">Automatically selected kernels:</span><br><span class="line">6.1.10-1-pve</span><br><span class="line">6.2.16-3-pve</span><br><span class="line"></span><br><span class="line">Pinned kernel:</span><br><span class="line">6.1.10-1-pve</span><br></pre></td></tr></tbody></table></figure></div></figure><p>重启就 OK 了  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;PVE 8.0 使用了新的 Linux 6.2 内核，但该内核版本也会使 RTL8168 网卡无法正常工作，需要降级内核版本才能使用&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://www.mbrjun.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="服务器" scheme="https://www.mbrjun.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="虚拟化" scheme="https://www.mbrjun.cn/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="PVE" scheme="https://www.mbrjun.cn/tags/PVE/"/>
    
    <category term="Proxmox VE" scheme="https://www.mbrjun.cn/tags/Proxmox-VE/"/>
    
    <category term="RTL8168" scheme="https://www.mbrjun.cn/tags/RTL8168/"/>
    
  </entry>
  
  <entry>
    <title>Proxmox VE 8 发布/更新教程</title>
    <link href="https://www.mbrjun.cn/archives/489/"/>
    <id>https://www.mbrjun.cn/archives/489/</id>
    <published>2023-06-23T16:00:00.000Z</published>
    <updated>2023-06-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Proxmox VE 8.0 已于 2023 年 6 月 22 日发布，PVE 8.0 使用 Linux 6.2 内核和最新的 Debian 12 Bookworm 底层系统</p><span id="more"></span><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><ul><li>默认使用 <code>x86-64-v2-AES</code> CPU 类型代替 <code>qemu64</code>&#x2F;<code>kvm64</code> 来提高性能  </li><li>ISO 安装新增 TUI</li><li>2FA 安全性提高</li><li>原生的深色模式</li><li>BtrFS 性能提升</li><li>核心软件包（<code>libc6</code>、<code>OpenSSL</code>、<code>OpenSSH</code>、<code>python3</code>等）更新</li></ul><h2 id="更新教程"><a href="#更新教程" class="headerlink" title="更新教程"></a>更新教程</h2><h3 id="检查现有版本"><a href="#检查现有版本" class="headerlink" title="检查现有版本"></a>检查现有版本</h3><p>在升级到 Proxmox VE 8.0 之前，您需要先升级到最新的 Proxmox VE 7.4  </p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">sh</li></ul></figcaption><div class="tabs-content"><figure class="highlight sh" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt dist-upgrade</span><br></pre></td></tr></tbody></table></figure></div></figure><p><img src="https://cos.mbrjun.cn/IMGS/2023/06/17/35267825-2bd1-4c47-ba1a-f0da940bd969.webp" alt="Upgrade to Proxmox VE 7.4"></p><p>无需重启，然后输入 <code>pveversion</code> 命令，检查版本是否已更新到 7.4-15 或更新版本  </p><h3 id="更新前检查"><a href="#更新前检查" class="headerlink" title="更新前检查"></a>更新前检查</h3><p>运行命令 <code>pve7to8 --full</code> 来自动检查是否能升级 Proxmox VE 8.0  </p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">txt</li></ul></figcaption><div class="tabs-content"><figure class="highlight txt" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">= SUMMARY =</span><br><span class="line">TOTAL:    34</span><br><span class="line">PASSED:   27</span><br><span class="line">SKIPPED:  3</span><br><span class="line">WARNINGS: 4</span><br><span class="line">FAILURES: 0</span><br><span class="line"></span><br><span class="line">ATTENTION: Please check the output for detailed information!</span><br></pre></td></tr></tbody></table></figure></div></figure><h3 id="cgroup2-迁移"><a href="#cgroup2-迁移" class="headerlink" title="cgroup2 迁移"></a>cgroup2 迁移</h3><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">sh</li></ul></figcaption><div class="tabs-content"><figure class="highlight sh" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">'s/lxc.cgroup./lxc.cgroup2./g'</span> /etc/pve/lxc/*.conf</span><br></pre></td></tr></tbody></table></figure></div></figure><h3 id="开始更新"><a href="#开始更新" class="headerlink" title="开始更新"></a>开始更新</h3><p><strong>我们需要先添加 Debian 12 和 Proxmox 8 存储库</strong>：  </p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">sh</li></ul></figcaption><div class="tabs-content"><figure class="highlight sh" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">'s/bullseye/bookworm/g'</span> /etc/apt/sources.list</span><br></pre></td></tr></tbody></table></figure></div></figure><p>如果你是一个企业订阅用户，继续执行：</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">sh</li></ul></figcaption><div class="tabs-content"><figure class="highlight sh" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"deb https://enterprise.proxmox.com/debian/pve bookworm pve-enterprise"</span> &gt; /etc/apt/sources.list.d/pve-enterprise.list</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"deb https://enterprise.proxmox.com/debian/ceph-quincy bookworm enterprise"</span> &gt; /etc/apt/sources.list.d/ceph.list</span><br></pre></td></tr></tbody></table></figure></div></figure><p>否则请使用：</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">sh</li></ul></figcaption><div class="tabs-content"><figure class="highlight sh" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"deb http://download.proxmox.com/debian/ceph-quincy bookworm no-subscription"</span> &gt; /etc/apt/sources.list.d/ceph.list</span><br><span class="line">sed -i -e <span class="string">'s/bullseye/bookworm/g'</span> /etc/apt/sources.list.d/pve-install-repo.list</span><br></pre></td></tr></tbody></table></figure></div></figure><p>完成后，使用 <code>apt update</code> 刷新软件源，<strong>然后运行 <code>apt dist-upgrade</code> 更新</strong>  </p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">txt</li></ul></figcaption><div class="tabs-content"><figure class="highlight txt" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1174 upgraded, 199 newly installed, 15 to remove and 0 not upgraded.</span><br><span class="line">Need to get 1,441 MB of archives.</span><br><span class="line">After this operation, 1,917 MB of additional disk space will be used.</span><br></pre></td></tr></tbody></table></figure></div></figure><h2 id="更新内容"><a href="#更新内容" class="headerlink" title="更新内容"></a>更新内容</h2><p>更新时，系统会发送一封邮件到管理员邮箱，其中包含了更新的内容  </p><p><img src="https://cos.mbrjun.cn/IMGS/2023/06/24/c59cc0b2-a320-4a07-80be-4fba93b73413.webp" alt="apt-listchanges"></p><h2 id="配置文件修改"><a href="#配置文件修改" class="headerlink" title="配置文件修改"></a>配置文件修改</h2><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">txt</li></ul></figcaption><div class="tabs-content"><figure class="highlight txt" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Configuration file '/etc/issue'</span><br><span class="line">==&gt; Modified (by you or by a script) since installation.</span><br><span class="line">==&gt; Package distributor has shipped an updated version.</span><br><span class="line">What would you like to do about it ?  Your options are:</span><br><span class="line">    Y or I  : install the package maintainer's version</span><br><span class="line">    N or O  : keep your currently-installed version</span><br><span class="line">    D     : show the differences between the versions</span><br><span class="line">    Z     : start a shell to examine the situation</span><br><span class="line">The default action is to keep your current version.</span><br><span class="line">*** issue (Y/I/N/O/D/Z) [default=N] ?</span><br></pre></td></tr></tbody></table></figure></div></figure><ul><li><code>/etc/issue</code> 建议使用 N</li><li><code>/etc/lvm/lvm.conf</code> 建议使用 Y</li><li><code>/etc/default/grub</code> 建议使用 N</li></ul><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>如果在更新过程中出现了错误（例如：SSH 连接中断、电源故障），导致更新中断，则可能需要使用下面的命令恢复：  </p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">sh</li></ul></figcaption><div class="tabs-content"><figure class="highlight sh" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt -f install</span><br></pre></td></tr></tbody></table></figure></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Proxmox VE 8.0 已于 2023 年 6 月 22 日发布，PVE 8.0 使用 Linux 6.2 内核和最新的 Debian 12 Bookworm 底层系统&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://www.mbrjun.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="服务器" scheme="https://www.mbrjun.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="虚拟化" scheme="https://www.mbrjun.cn/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="ESXi" scheme="https://www.mbrjun.cn/tags/ESXi/"/>
    
    <category term="软路由" scheme="https://www.mbrjun.cn/tags/%E8%BD%AF%E8%B7%AF%E7%94%B1/"/>
    
    <category term="PVE" scheme="https://www.mbrjun.cn/tags/PVE/"/>
    
    <category term="Proxmox VE" scheme="https://www.mbrjun.cn/tags/Proxmox-VE/"/>
    
  </entry>
  
  <entry>
    <title>Can A Few Make A Difference?</title>
    <link href="https://www.mbrjun.cn/archives/488/"/>
    <id>https://www.mbrjun.cn/archives/488/</id>
    <published>2023-05-25T16:13:33.000Z</published>
    <updated>2023-05-25T16:13:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>Some of the greatest problems we face today are the destruction of our environment. Brown clouds, polluted water, endangered wild animals…, these problems seem so huge.  </p><p>So my family does what we can. We take cloth bags to stores instead of using plastic bags. We walk where we don’t have to drive…  </p><p>But does it do any good? When I am the only one in line at the market with cloth bags, am I doing any good? Does my walking to stores make any real difference to the world?  </p><span id="more"></span><p>I recently learned something about flamingos which like to get together in groups of a thousand or more. Every year, when the time comes for migration, a few of them first takeoff from the lake. But none of the others seem to notice, so the small group returns.  </p><p>However, the next day they try again. This time few more fly along with them, but most of them still pay no attention, so they return again. They try for several times. Every time a few more birds join in but, since the thousands of others still take no notice, the great migration plan is once more stopped.  </p><p>Then one day something changes. The same small group of birds once again starts flying and a small number more join in just as before, then more. Finally, they all take flight and the migration really begins.  </p><p>What a spectacular sight it must be-thousands of flamingos taking off into the sky at once!  </p><p>A few can make a difference. Even if you’re the one to take the first step, and continue trying, others will someday take notice and together we will solve even our greatest problems.  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Some of the greatest problems we face today are the destruction of our environment. Brown clouds, polluted water, endangered wild animals…, these problems seem so huge.  &lt;/p&gt;
&lt;p&gt;So my family does what we can. We take cloth bags to stores instead of using plastic bags. We walk where we don’t have to drive…  &lt;/p&gt;
&lt;p&gt;But does it do any good? When I am the only one in line at the market with cloth bags, am I doing any good? Does my walking to stores make any real difference to the world?  &lt;/p&gt;</summary>
    
    
    
    <category term="日常" scheme="https://www.mbrjun.cn/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="Environment" scheme="https://www.mbrjun.cn/tags/Environment/"/>
    
    <category term="flamingos" scheme="https://www.mbrjun.cn/tags/flamingos/"/>
    
    <category term="Plastic Pollution" scheme="https://www.mbrjun.cn/tags/Plastic-Pollution/"/>
    
    <category term="Cloth Bags" scheme="https://www.mbrjun.cn/tags/Cloth-Bags/"/>
    
  </entry>
  
  <entry>
    <title>中通快递送丢一张 AIME 卡</title>
    <link href="https://www.mbrjun.cn/archives/487/"/>
    <id>https://www.mbrjun.cn/archives/487/</id>
    <published>2023-05-19T11:49:00.000Z</published>
    <updated>2023-05-19T11:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>送丢的是 maimai FESTiVAL 的限定卡，最后快递赔了 385 CNY  </p><span id="more"></span><p><img src="https://cos.mbrjun.cn/IMGS/2023/05/23/4e72591d-1952-4b35-90ec-a885b90dc3d4.webp" alt="maimai FESTiVAL aime"></p><p>快递卡了四天不动，开了个投诉单，然后快递说在找  </p><p>转天就告诉我件丢了  </p><blockquote><p>【中通】您好我是中通锦绣分部网点的客服工号是001您反馈的单号尾号8155发件催件的问题很抱歉给您带来了不便，经核实此件疑似不慎遗失，我司已微信理赔寄件人385元，我司联系寄件人后台给您处理售后问题，因我司电联联系不上您按短信内容有问题请联系17635999968</p></blockquote><p><del>不会真的是快递员太馋了给私吞了吧</del>  </p><p>物流信息到现在也没更新，不知道中通还能不能找到件  </p><p><img src="https://cos.mbrjun.cn/IMGS/2023/05/23/112c2594-a974-460a-8235-1807195d8537.webp" alt="ZTO 78685530518155"><br>运单号： <code>78685530518155</code>（<a href="https://www.17track.net/?nums=78685530518155">追踪</a>）  </p><p><img src="https://cos.mbrjun.cn/IMGS/2023/05/23/90c73b90-66a6-405c-ac92-beba0bbc1a7c.webp" alt="maimai FESTiVAL aime"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;送丢的是 maimai FESTiVAL 的限定卡，最后快递赔了 385 CNY  &lt;/p&gt;</summary>
    
    
    
    <category term="日常" scheme="https://www.mbrjun.cn/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="maimai" scheme="https://www.mbrjun.cn/tags/maimai/"/>
    
    <category term="中通快递" scheme="https://www.mbrjun.cn/tags/%E4%B8%AD%E9%80%9A%E5%BF%AB%E9%80%92/"/>
    
    <category term="头文字D" scheme="https://www.mbrjun.cn/tags/%E5%A4%B4%E6%96%87%E5%AD%97D/"/>
    
    <category term="中二" scheme="https://www.mbrjun.cn/tags/%E4%B8%AD%E4%BA%8C/"/>
    
    <category term="AIME" scheme="https://www.mbrjun.cn/tags/AIME/"/>
    
    <category term="AmusementIC" scheme="https://www.mbrjun.cn/tags/AmusementIC/"/>
    
  </entry>
  
  <entry>
    <title>使用 JS Fetch 测试网站连通性</title>
    <link href="https://www.mbrjun.cn/archives/486/"/>
    <id>https://www.mbrjun.cn/archives/486/</id>
    <published>2023-05-11T13:56:02.000Z</published>
    <updated>2023-05-11T13:56:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在浏览器或-Node-js-中使用-JavaScript-的-Fetch-测试网站连通性"><a href="#在浏览器或-Node-js-中使用-JavaScript-的-Fetch-测试网站连通性" class="headerlink" title="在浏览器或 Node.js 中使用 JavaScript 的 Fetch 测试网站连通性"></a>在浏览器或 Node.js 中使用 JavaScript 的 Fetch 测试网站连通性<br><span id="more"></span></h2><p>自己有在浏览器测试网站连通性的需求，最后使用 Fetch 实现了，就在这里分享一下中间遇到的坑和最后的解决方案，不想看前面废话可以直接<a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">跳转文末查看代码</a>  </p><h2 id="XHR"><a href="#XHR" class="headerlink" title="XHR"></a>XHR</h2><p>最开始打算直接用 <code>XMLHttpRequest</code> 解决，但是浏览器遇到了跨域拦截（CORS 失败）  </p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">js</li></ul></figcaption><div class="tabs-content"><figure class="highlight js" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">'get'</span>, <span class="string">'https://www.google.com'</span>, !<span class="number">0</span>);</span><br><span class="line"><span class="comment">// async 参数被设置为 !0</span></span><br><span class="line"><span class="comment">// !0 在 JS 中是 true 的一种简写</span></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></tbody></table></figure></div></figure><p><img src="https://cos.mbrjun.cn/IMGS/2023/05/11/bb7d4f58-4c87-4259-be7b-0a418c637084.webp" alt="XHR CORS"></p><p>出现 <code>Access to XMLHttpRequest at (url) from origin (src) has been blocked by CORS policy: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.</code> 报错，是因为待测的目标 URL（在这个示例中是 <a href="https://www.google.com/">https://www.google.com</a> ）没有允许浏览器读取响应信息  </p><p>正常情况下，<code>xhr.status</code> 应该会给我们响应的状态码，浏览器此时已经成功收到了 302 重定向的响应，但是 xhr 请求出现了 CORS 错误，再尝试获取这个状态码只能得到 0<br>也就是说，无论是否可以访问待测网站，<code>xhr.status</code> 都只会返回 0  </p><p>在浏览器中，XHR 请求都受到 CORS 策略的限制，而 XHR 也无法使用 <code>no-cors</code> 模式来绕过这个限制，这个时候，我们就需要使用 <code>Fetch</code> 了</p><h2 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h2><p><code>Fetch</code> 是 <code>XMLHttpRequest</code> 更现代的替代品，是 ES6（ECMAScript 2015）的东西（也就是说不支持 IE）  </p><p>除了过时的 Internet Explorer 和 Windows Script Host，基本所有可以执行 JS 的地方都能使用 <code>Fetch</code>，你甚至可以在 Node.js 中使用它  </p><p>先用 <code>Fetch</code> 重写下文章开头的代码  </p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">js</li></ul></figcaption><div class="tabs-content"><figure class="highlight js" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">"https://www.google.com"</span>, {</span><br><span class="line">    <span class="attr">method</span>: <span class="string">"GET"</span>,</span><br><span class="line">    <span class="attr">body</span>: <span class="literal">null</span>,</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></div></figure><p><img src="https://cos.mbrjun.cn/IMGS/2023/05/11/9fd946c9-88c5-4393-8d46-c4d8067884b6.webp" alt="Fetch CORS"></p><p>同样会获得 CORS 错误，提示 <code>Failed to fetch</code>，注意看，这个错误属于 <code>TypeError</code>  </p><p>但是我们可以让 <code>Fetch</code> 使用 <code>no-cors</code>，来绕过这个 CORS 限制！</p><p>改进一下代码，然后观察 <code>Fetch</code> 出现的 Error：</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">js</li></ul></figcaption><div class="tabs-content"><figure class="highlight js" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="title function_">fetch</span>(<span class="string">"https://www.google.com"</span>, {</span><br><span class="line">    <span class="attr">method</span>: <span class="string">"GET"</span>,</span><br><span class="line">    <span class="attr">body</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">'no-cors'</span></span><br><span class="line">})</span><br><span class="line">request.<span class="title function_">then</span>( <span class="function"><span class="params">res</span> =&gt;</span> {</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">      <span class="keyword">return</span> res.<span class="title function_">json</span>()</span><br><span class="line">})</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Error:'</span>, error))</span><br><span class="line">.<span class="title function_">then</span>( <span class="function"><span class="params">response</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Success:'</span>, response));</span><br></pre></td></tr></tbody></table></figure></div></figure><p>执行这段代码，我们会得到 <code>Error: SyntaxError: Unexpected end of input</code>  </p><p>为什么会得到 <code>SyntaxError</code> 呢？因为 no-cors 会阻止浏览器获取响应的内容  </p><p>但实际上，如果我们得到了 <code>SyntaxError</code>，则说明这个请求已经发送成功，并且接收到了响应  </p><p>让我们将测试 URL 改为一个不存在的地址，再试一遍：  </p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">js</li></ul></figcaption><div class="tabs-content"><figure class="highlight js" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="title function_">fetch</span>(<span class="string">"https://this.domain.does.not.exist"</span>, {</span><br><span class="line">    <span class="attr">method</span>: <span class="string">"GET"</span>,</span><br><span class="line">    <span class="attr">body</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">'no-cors'</span></span><br><span class="line">})</span><br><span class="line">request.<span class="title function_">then</span>( <span class="function"><span class="params">res</span> =&gt;</span> {</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">      <span class="keyword">return</span> res.<span class="title function_">json</span>()</span><br><span class="line">})</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Error:'</span>, error))</span><br><span class="line">.<span class="title function_">then</span>( <span class="function"><span class="params">response</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Success:'</span>, response));</span><br></pre></td></tr></tbody></table></figure></div></figure><p>执行代码，我们会得到 <code>Error: TypeError: Failed to fetch</code>  </p><p>也就是说，带上 <code>no-cors</code> 之后，虽然请求成功也会报错，但是出现的是另一个报错  </p><ul><li>请求成功：<code>SyntaxError</code></li><li>请求失败：<code>TypeError</code></li></ul><p>接下来，对着不同错误做不同处理，就可以检测啦</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>直接放代码：  </p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">js</li></ul></figcaption><div class="tabs-content"><figure class="highlight js" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="title function_">fetch</span>(<span class="string">"https://www.google.com"</span>, {</span><br><span class="line">    <span class="attr">method</span>: <span class="string">"GET"</span>,</span><br><span class="line">    <span class="attr">body</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">'no-cors'</span></span><br><span class="line">})</span><br><span class="line">request.<span class="title function_">then</span>( <span class="function"><span class="params">res</span> =&gt;</span> { <span class="keyword">return</span> res.<span class="title function_">json</span>() })</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> { </span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="title class_">SyntaxError</span>){ <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Google OK'</span>)} </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="title class_">TypeError</span>) { <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Google Failed'</span>)} </span><br><span class="line">    <span class="keyword">else</span> {<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Unknown Error:'</span> + e)}</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure></div></figure><p>如果请求成功，控制台输出 Google OK，如果失败，输出 Google Failed  </p><p>这段代码可以在浏览器里面跑，也可以使用 Node.js 运行</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;在浏览器或-Node-js-中使用-JavaScript-的-Fetch-测试网站连通性&quot;&gt;&lt;a href=&quot;#在浏览器或-Node-js-中使用-JavaScript-的-Fetch-测试网站连通性&quot; class=&quot;headerlink&quot; title=&quot;在浏览器或 Node.js 中使用 JavaScript 的 Fetch 测试网站连通性&quot;&gt;&lt;/a&gt;在浏览器或 Node.js 中使用 JavaScript 的 Fetch 测试网站连通性&lt;br&gt;</summary>
    
    
    
    <category term="JS" scheme="https://www.mbrjun.cn/categories/JS/"/>
    
    
    <category term="JavaScript" scheme="https://www.mbrjun.cn/tags/JavaScript/"/>
    
    <category term="fetch" scheme="https://www.mbrjun.cn/tags/fetch/"/>
    
    <category term="GFW" scheme="https://www.mbrjun.cn/tags/GFW/"/>
    
  </entry>
  
</feed>
