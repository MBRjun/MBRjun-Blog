<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="MBRjun-Blog"><title>TLS 1.3 和 0-RTT - MBRjun-Blog</title><meta name="author" content="MBRjun"><meta name="keywords" content="MBRjun,Linux,服务器,软路由,PVE,原神,maimai,JavaScript,Windows,Microsoft,git,Node.JS,"><link rel="icon" href="https://lfs.libmbr.com/assets/pics/LG4v5Ravatar180px.webp"><link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml"><script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"MBRjun","sameAs":["https://github.com/MBRjun","https://twitter.com/MBRjun","mailto:neko@mbr.moe"],"image":"https://lfs.libmbr.com/assets/pics/LG4v5Ravatar180px.webp"},"articleBody":"写一篇关于 TLS 1.3 的文章\n\n\n\n首先需要明确的是，同等情况下，TLS1.3 比 1.2 少一个 RTT 时间。\n客户端完成 TCP 握手需要一个 RTT 时间， TLS1.2 完成TLS 密钥协商需要两个 RTT 时间， TLS1.3 只需要一个 RTT 时间。因此对于 https， 收到第一个 http 响应包，TLS1.2 需要 4 个 RTT 时间， TLS1.3 需要 3 个 RTT 时间。\n考虑 session 重用，根据数据表明，大部分的 TLS 的请求都在重用， TLS1.2 session 重用需要一个 RTT 时间，  TLS1.3 则因为在第一个包中携带数据，只需要0个 RTT，有点类似 TLS 层的TCP Fast Open。因此对于 https， 收到第一个 http 响应包，比非重用减少一个 RTT， TLS1.2 需要3个 RTT 时间， TLS1.3 需要2个 RTT 时间。\n另外如果开启 TCP 的 TFO，收到第一个 https 响应包的时间，则再减少一个 RTT，在 session 重用的时候就是 TLS1.2 需要2个 RTT，TLS1.3 只需要1个 RTT 时间。\nHow为什么 TLS 1.3 能少一个 RTT 时间？\n考虑 TLS 1.2, 下面握手流程来自 RFC5246 ，在第一个 RTT 需要协商算法版本等信息， 在第二个 RTT 才能完成对称密钥的协商。\n1234567891011121314151617Client                                        ServerClientHello             --------&gt;                                         ServerHello                                        Certificate*                                  ServerKeyExchange*                                 CertificateRequest*                        &lt;--------    ServerHelloDoneCertificate*ClientKeyExchangeCertificateVerify*[ChangeCipherSpec]Finished                --------&gt;                                  [ChangeCipherSpec]                        &lt;--------           FinishedApplication Data        &lt;-------&gt;   Application Data    Figure 1.  Message flow for a full handshake\n\n如果要减少 RTT，就是解决如何在第一个 RTT 内就能完成密钥的协商？因为 TLS 1.3 只支持 PFS 的算法，已经取消了 RSA 作为密钥协商算法， 因此以下讨论仅用 ECDHE 来说明。\n使用 ECDHE 需要解决以下问题:\n\n双方把自己的公钥发送给对方\n确认发送的公钥信息没有被中间人篡改\n\n很自然的，我们会考虑能不能把 ECDHE 的公钥在 client hello 中发送?服务端收到 client hello 后，随机生成本地的 ECDHE 私钥后，就能直接能计算出 pre-master secret，进而计算出所有密钥。同时服务端发送 finish 消息，通过 hmac 验证，client hello 中的 ECDHE 公钥没有被篡改。\n在第二个 RTT 开始，收到 server hello 后，client 也能通过服务端 ECDHE 的公钥计算出 pre-master secret，发送自己的 Finish 消息，并和应用数据一起发送。 服务端验证 Finish 成功后才接收数据。\n上面分析，完全是拍脑袋的结果，事实上 TLS 1.3 是这样吗？\nTLS 1.3对比TLS 1.2主要的修改如下:\n\n使用更严格的算法，只使用 PFS 的算法，如禁用了 RSA 密钥协商， 只使用 AEAD 算法\n使用 HKDF 密钥导出算法替代 PRF 算法\nserver hello 之后的握手包也开始加密， 并去掉了changeCipherSpec 消息\n更改了 session 重用机制， 使用 PSK 的机制，同时 session ticket 中添加了过期时间。 过去 TLS 1.2 中的 ticket 不包含过期时间，只能通过 ticket key 的更新让之前所有发送的 ticket 都失效\n版本协商作为 client hello 的扩展，提供版本列表\n支持 0-RTT 发送\n\n\n后文所有的代码来源于下面两个库，server 端源码来自 Cloudflare 的 tls-tris，Client 端参考了 bifurcation&#x2F;mint\nclientHello如前文所述， TLS 1.3 为了减少一个 RTT 时间，必须在 client hello 中发送本地的 ECDHE 的公钥，因为可能支持多个曲线，所以需要发送每个曲线的 ECDHE 公钥。每个公钥和对应的曲线， 称为 keyShare。 keyshare 列表作为 clientHello 的扩展被发送\n12345// 每个 keyShare 的条目，包含曲线 ID 和公钥struct &#123;       NamedGroup group;       opaque key_exchange&lt;1..2^16-1&gt;;   &#125; KeyShareEntry;\n\n123456789101112131415161718func (h *ClientHandshake) CreateClientHello(opts ConnectionOptions, caps Capabilities) (*HandshakeMessage, error) &#123;\t// key_shares\th.OfferedDH = map[NamedGroup][]byte&#123;&#125;\tks := KeyShareExtension&#123;\t\tHandshakeType: HandshakeTypeClientHello,\t\tShares:        make([]KeyShareEntry, len(caps.Groups)),\t&#125;\tfor i, group := range caps.Groups &#123;\t\tpub, priv, err := newKeyShare(group)\t//为每个支持的曲线，生成公私钥，作为keyshare\t\tif err != nil &#123;\t\t\treturn nil, err\t\t&#125;\t\tks.Shares[i].Group = group\t\tks.Shares[i].KeyExchange = pub\t\th.OfferedDH[group] = priv\t&#125;\t...&#125;\n\nserverHelloand HelloRetryRequest, EncryptedExtensions, CertificateRequest, Certifacate, CertificateVerify, Finished\n服务端收到 client 后，协商曲线，如果有支持的曲线则使用该 keyshare， 否则发送 HelloRetryRequest 消息通知client。\n服务端生成 ECDHE 公私钥后， 通过客户端的 keyShare 协商出密钥 ECDHESecret(TLS 1.2 中的 premaster secret)。然后通过 serverHello 发送服务端的 keyShare。需要注意的是 keyShare 没有使用私钥签名， 整个过程的不可抵赖和防篡改是通过 certificateVerify 证明持有私钥，以及 finished 消息使用 hmac 验证历史消息来确定的。\nserverHello 之后的握手消息需要加密，导出加密密钥。通过 early secret 和 ECDHE secre t导出server_handshake_traffic_secret。再从 server_handshake_traffic_secret 中导出 key 和 iv，使用该 key 和 iv 对 server hello 之后的握手消息加密。同样的计算 client_handshake_traffic_secret，使用对应的 key 和 iv 进行解密后续的握手消息\n\n1234567891011Derive-Secret(Secret, Label, Messages) =         HKDF-Expand-Label(Secret, Label,                           Transcript-Hash(Messages), Hash.length)early secret=HKDF-Extract(0,0)Handshake Secret = HKDF-Extract(ecdhe secret, early secret)server_handshake_traffic_secret = Derive-Secret(Handshake Secret, &quot;server handshake traffic secret&quot;, ClientHello...ServerHello) client_handshake_traffic_secret = Derive-Secret(Handshake Secret, &quot;server handshake traffic secret&quot;, ClientHello...ServerHello) server_handshake_key := hkdfExpandLabel(hash, server_handshake_traffic_secret, nil, &quot;key&quot;, hs.suite.keyLen)server_handshake_iv := hkdfExpandLabel(hash, server_handshake_traffic_secret, nil, &quot;iv&quot;, 12)client_handshake_key := hkdfExpandLabel(hash, server_handshake_traffic_secret, nil, &quot;key&quot;, hs.suite.keyLen)client_handshake_iv := hkdfExpandLabel(hash, server_handshake_traffic_secret, nil, &quot;iv&quot;, 12)\n\n\n在 EncryptedExtensions 消息中发送扩展信息，比如 alpn 协议，服务端是否支持 earlyData\n如果服务端需要客户端证书，则发送 CertificateRequest , 在其扩展中指定支持的签名算法和CA\n发送 certificate 和 certificateVerify 消息在 certificate 可以指定 OCSP stapling和 sct。certificateVerify 跟以前 client 发送的类似， 使用私钥对历史握手消息的摘要进行签名, 并发送签名的算法。\n发送 finished 消息, 从 server_handshake_traffic_secret 中导出 serverFinishedKey， 使用 hmac 计算 finished 后发送。 TLS 1.2 是使用 PRF(master_secret, digest(handshake)) 导出的。\n导出最终的对称密钥。 先从 Handshake Secret 中导出 master secret，再从 master secret 导出两个方向的对称密钥 key 和  iv\n\n123masterSecret = hkdfExtract(hash, nil, Handshake Secret)client_application_traffic_secret_0 = Derive-Secret(masterSecret, &quot;client application traffic secret&quot;, ClientHello...server Finished)server_application_traffic_secret_0 = Derive-Secret(masterSecret, &quot;server application traffic secret&quot;, ClientHello...server Finished)\n\nCertifacateand CertificateVerify, Finished客户端收到 serverHello 后，通过 server 的 keyshare 计算出 ECDHE secret。然后跟 server 端一样，通过一系列的 khdf 密钥导出， 两个方向的后续握手密钥，以及 master secret 和两个方向的 application traffic secret。因为 client 和 server 端 early secret 和协商出来的 ecdhe secret 相同， 因此所有后续导出的对应的密钥都是相同的。\n12345678early secret=HKDF-Extract(0,0)Handshake Secret = HKDF-Extract(ecdhe secret, early secret)server_handshake_traffic_secret = Derive-Secret(Handshake Secret, &quot;server handshake traffic secret&quot;, ClientHello...ServerHello)client_handshake_traffic_secret = Derive-Secret(Handshake Secret, &quot;client handshake traffic secret&quot;, ClientHello...ServerHello)masterSecret = hkdfExtract(hash, nil, Handshake Secret)client_application_traffic_secret_0 = Derive-Secret(masterSecret, &quot;client application traffic secret&quot;, ClientHello...server Finished)server_application_traffic_secret_0 = Derive-Secret(masterSecret, &quot;server application traffic secret&quot;, ClientHello...server Finished)resumption_master_secret = Derive-Secret(masterSecret, &quot;resumption master secret&quot;,  hash(all handshake message))\n\n发送 finished 后， 就完成了整个握手信息， 通过 master secret 和整个握手的摘要，计算 resumption secret\nnewSessionTicket\n收到客户端的 Certifacate 和 CertificateVerify，同样进行证书链的认证以及验证签名\n服务端收到客户端的 finished 消息后，验证完后，同样计算 resumption secret\n发送 new session ticket，包含整个 session 的信息。  newSessionTicket 使用server_application_traffic_secret 加密在加密的ticket中，相比 TLS1.2，包含了当前的创建时间，因此可以方便的配置和验证 ticket 的过期时间。\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364func (hs *serverHandshakeState) sendSessionTicket13() error &#123;\tc := hs.c\tif c.config.SessionTicketsDisabled &#123;\t\treturn nil\t&#125;\tfoundDHE := false\tfor _, mode := range hs.clientHello.pskKeyExchangeModes &#123;\t\tif mode == pskDHEKeyExchange &#123;\t\t\tfoundDHE = true\t\t\tbreak\t\t&#125;\t&#125;\tif !foundDHE &#123;\t\treturn nil\t&#125;\t//只支持dhe的方式计算psk\thash := hashForSuite(hs.suite)\thandshakeCtx := hs.finishedHash13.Sum(nil)\tresumptionSecret := hkdfExpandLabel(hash, hs.masterSecret, handshakeCtx, &quot;resumption master secret&quot;, hash.Size())\tageAddBuf := make([]byte, 4)\tsessionState := &amp;sessionState13&#123;\t\t//需要加密的session信息，包含resumptionSecret\t\tvers:             c.vers,\t\tsuite:            hs.suite.id,\t\tcreatedAt:        uint64(time.Now().Unix()),\t\tresumptionSecret: resumptionSecret,\t\talpnProtocol:     c.clientProtocol,\t\tSNI:              c.serverName,\t\tmaxEarlyDataLen:  c.config.Max0RTTDataSize,\t&#125;\tfor i := 0; i &lt; numSessionTickets; i++ &#123;\t\tif _, err := io.ReadFull(c.config.rand(), ageAddBuf); err != nil &#123;\t//随机生成ageAddBuf\t\t\tc.sendAlert(alertInternalError)\t\t\treturn err\t\t&#125;\t\tsessionState.ageAdd = uint32(ageAddBuf[0])&lt;&lt;24 | uint32(ageAddBuf[1])&lt;&lt;16 |\t//ageAdd使用随机值\t\t\tuint32(ageAddBuf[2])&lt;&lt;8 | uint32(ageAddBuf[3])\t\tticket := sessionState.marshal()\t\tvar err error\t\tif c.config.SessionTicketSealer != nil &#123;\t\t\tcs := c.ConnectionState()\t\t\tticket, err = c.config.SessionTicketSealer.Seal(&amp;cs, ticket)\t\t&#125; else &#123;\t\t\tticket, err = c.encryptTicket(ticket)\t//使用tiket key加密\t\t&#125;\t\tif err != nil &#123;\t\t\tc.sendAlert(alertInternalError)\t\t\treturn err\t\t&#125;\t\tif ticket == nil &#123;\t\t\tcontinue\t\t&#125;\t\tticketMsg := &amp;newSessionTicketMsg13&#123;\t\t\tlifetime:           24 * 3600, // TODO(filippo)\t//24小时\t\t\tmaxEarlyDataLength: c.config.Max0RTTDataSize,\t\t\twithEarlyDataInfo:  c.config.Max0RTTDataSize &gt; 0,\t\t\tageAdd:             sessionState.ageAdd,\t//随机值\t\t\tticket:             ticket,\t//session信息\t\t&#125;\t\tif _, err := c.writeRecord(recordTypeHandshake, ticketMsg.marshal()); err != nil &#123;\t\t\treturn err\t\t&#125;\t&#125;\treturn nil&#125;\n\nsession 重用和 0-RTTclient 收到 NewSessionTicket 消息后,收到的 ticket 和客户端本地发送 finished 后计算的 resumptionSecret，两者一起组成了 PreSharedKey，即 PSK。然后 client 把 PSK 保存到本地 cache 中， serverName 作为 cache 的 key。\n12345678910111213func (h *ClientHandshake) HandleNewSessionTicket(hm *HandshakeMessage) (PreSharedKey, error) &#123;\tvar tkt NewSessionTicketBody\t_, err := tkt.Unmarshal(hm.body)\t\tpsk := PreSharedKey&#123;\t\tCipherSuite:  h.Context.suite,\t\tIsResumption: true,\t\tIdentity:     tkt.Ticket,\t\t// ticket 中也包含 resumptionSecret，但是被加密\t\tKey:          h.Context.resumptionSecret,\t\t//客户端本地发送 finished 后计算的 resumptionSecret\t&#125;\treturn psk, nil&#125;c.config.PSKs.Put(c.config.ServerName, psk)\t\t//这里使用 serverName 做为 key\n\nclient在 client hello 中，会在本地 cache 中查找 servername 对应的 PSK， 找到后则在 client hello 的 psk 扩展中带上两部分\n\nIdentity: 就是 NewSessionTicket 中加密的 ticket\nBinder: 从之前 client 发送 finished 计算的 resumption secret，导出 early secret，进而导出后续的 binderKey 和 binder_macKey， 使用 binder_macKey 对不包含 PSK 部分的 clientHello 作HMAC\n\n123456Early Secret = HKDF-Extract(0, resumption secret)binder_key = deriveSecret(Early Secret, &quot;resumption psk binder key&quot;, &quot;&quot;)binder_macKey = hkdfExpandLabel(ctx.params.hash, binder_key, &quot;finished&quot;, []byte&#123;&#125;, ctx.params.hash.Size())earlyTrafficSecret = ctx.deriveSecret(Early Secret, &quot;client early traffic secret&quot;, clientHello)earlyExporterSecret = ctx.deriveSecret(Early Secret, &quot;early exporter master secret&quot;, ClientHello)clientEarlyTrafficKey,  clientEarlyTrafficIv= ctx.makeTrafficKeys(earlyTrafficSecret)\n\n通过 resumption secret 最终导出 earlyData 的加密密钥，以及 PSK 扩展中 binder 的 hmac 密钥。发送 clientHello 后，使用 resumption secret 导出的 clientEarlyTrafficKey 和 IV，对 early data 加密后发送。\n需要注意的是 earlydata 在 ticket 有效期内，不能防止重放攻击。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103func (h *ClientHandshake) CreateClientHello(opts ConnectionOptions, caps Capabilities) (*HandshakeMessage, error) &#123;\t// key_shares\th.OfferedDH = map[NamedGroup][]byte&#123;&#125;\tks := KeyShareExtension&#123;\t\tHandshakeType: HandshakeTypeClientHello,\t\tShares:        make([]KeyShareEntry, len(caps.Groups)),\t&#125;\tfor i, group := range caps.Groups &#123;\t\tpub, priv, err := newKeyShare(group)\t//为每个支持的曲线，生成公私钥，作为keyshare\t\tif err != nil &#123;\t\t\treturn nil, err\t\t&#125;\t\tks.Shares[i].Group = group\t\tks.Shares[i].KeyExchange = pub\t\th.OfferedDH[group] = priv\t&#125;\t...\tif key, ok := caps.PSKs.Get(opts.ServerName); ok &#123; //从cache中获取PSK，尝试session重用\t\th.OfferedPSK = key\t\tkeyParams, ok := cipherSuiteMap[key.CipherSuite]\t\tcompatibleSuites := []CipherSuite&#123;&#125;\t\tfor _, suite := range ch.CipherSuites &#123;\t\t\tif cipherSuiteMap[suite].hash == keyParams.hash &#123;\t\t\t\tcompatibleSuites = append(compatibleSuites, suite)\t\t\t&#125;\t\t&#125;\t\tch.CipherSuites = compatibleSuites\t//更新psk能使用的算法\t\tif opts.EarlyData != nil &#123;\t\t//使用psk的话可以使用0-rtt发送early data\t\t\ted = &amp;EarlyDataExtension&#123;&#125;\t//开启early data\t\t\tch.Extensions.Add(ed)\t\t&#125;\t\t\t\tpsk = &amp;PreSharedKeyExtension&#123;\t\t\tHandshakeType: HandshakeTypeClientHello,\t\t\tIdentities: []PSKIdentity&#123;\t\t\t\t&#123;Identity: key.Identity&#125;,\t//Identity就是加密的ticket\t\t\t&#125;,\t\t\tBinders: []PSKBinderEntry&#123;\t\t\t\t// Note: Stub to get the length fields right\t\t\t\t&#123;Binder: bytes.Repeat([]byte&#123;0x00&#125;, keyParams.hash.Size())&#125;,\t\t\t&#125;,\t\t&#125;\t\tch.Extensions.Add(psk)\t//添加psk作为client hello的扩展\t\th.Context.preInit(key)\t//从resumption secret导出early secret-&gt;binder key\t\ttrunc, err := ch.Truncated()\t//clientHello减去psk 扩展部分\t\ttruncHash := h.Context.params.hash.New()\t\ttruncHash.Write(trunc)\t\tbinder := h.Context.computeFinishedData(h.Context.binderKey, truncHash.Sum(nil))\t//binder_key导出macKey, 计算clientHello hmac\t\t// Replace the PSK extension\t\tpsk.Binders[0].Binder = binder\t//client hello的hmac\t\tch.Extensions.Add(psk) //替换psk扩展\t\th.clientHello, err = HandshakeMessageFromBody(ch)\t//重新构造client hello\t\t\t\th.Context.earlyUpdateWithClientHello(h.clientHello)\t//导出client_early_traffic_secret及其key和iv，作为0-RTT的early data的密钥\t&#125;\t...&#125;func (c *Conn) clientHandshake() error &#123;\tlogf(logTypeHandshake, &quot;Starting clientHandshake&quot;)\th := &amp;ClientHandshake&#123;&#125;\thIn := NewHandshakeLayer(c.in)\thOut := NewHandshakeLayer(c.out)\t// Generate ClientHello\tcaps := Capabilities&#123;\t\tCipherSuites:     c.config.CipherSuites,\t\tGroups:           c.config.Groups,\t\tSignatureSchemes: c.config.SignatureSchemes,\t\tPSKs:             c.config.PSKs,\t\tPSKModes:         c.config.PSKModes,\t\tCertificates:     c.config.Certificates,\t&#125;\topts := ConnectionOptions&#123;\t\tServerName: c.config.ServerName,\t\tNextProtos: c.config.NextProtos,\t\tEarlyData:  c.earlyData,\t&#125;\tchm, err := h.CreateClientHello(opts, caps)\tif err != nil &#123;\t\treturn err\t&#125;\t// Write ClientHello\terr = hOut.WriteMessage(chm)\tif err != nil &#123;\t\treturn err\t&#125;\tif opts.EarlyData != nil &#123;\t//使用client_early_traffic_secret的key/iv加密early data， 支持0-rtt发送\t\t// Rekey output to early data keys\t\terr = c.out.Rekey(h.Context.params.cipher, h.Context.clientEarlyTrafficKeys.key, h.Context.clientEarlyTrafficKeys.iv)\t\t// Send early application data\t\tlogf(logTypeHandshake, &quot;[client] Sending data...&quot;)\t\t_, err = c.Write(opts.EarlyData)\t\tif err != nil &#123;\t\t\treturn err\t\t&#125;\t\t// Send end_of_earlyData\t\tlogf(logTypeHandshake, &quot;[client] Sending end_of_early_data...&quot;)\t\terr = c.sendAlert(AlertEndOfEarlyData)\t//发送end_of_early_data alert标记early data结束\t\tif err != nil &#123;\t\t\treturn err\t\t&#125;\t&#125;\t...&#125;\n\nserver和 TLS 1.2 之前不同， session 重用，使用的不是过去的 master secret。TLS1.2 加密 ticket 后使用过去的 master secret，然后和两个随机数作为参数，一起 PRF 导出密钥。而 TLS 1.3 只使用过去的 resumption secret 导出 early data 的密钥， 之后的密钥会和 ECDHE secret，一起导出。\n\n服务端收到 client hello 后，生成本地的 keyShare\n检查 client hello 的 PSK 扩展， 解密 ticket，查看该 ticket 是否过期，已经版本算法等协商结果是否可用，然后使用 ticket 中的 resumption secret 计算 client hello 的 hmac， 检查 binder 是否正确。\n验证完 ticket 和 binder 之后，在 serverHello 中表示使用 PSK，以及哪个 PSK。\n和 client 一样，从 resumtion secret 中导出 earlyData 使用的密钥\n和不使用 session 重用一样，导出后续的密钥，唯一不同的是 resumption secret 作为 early secret 的输入\n收到 endOfEarlyData alert 后，切换到 client 方向的应用程序密钥\nserverHello 发送后依然会发送 EncryptedExtensions 和 Finished 消息，但不会再发送 Certificate 和 CerficateVerify 消息。\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136func (hs *serverHandshakeState) doTLS13Handshake() error &#123;\t\tvar ks keyShareCurvePreferenceLoop:\tfor _, curveID := range config.curvePreferences() &#123;\t// tls 1.3所有的曲线，都必须生成对应的keyshare， keyshare中包含dh的公钥\t\tfor _, keyShare := range hs.clientHello.keyShares &#123;\t\t\tif curveID == keyShare.group &#123;\t\t\t\tks = keyShare\t\t\t\tbreak CurvePreferenceLoop\t\t\t&#125;\t\t&#125;\t&#125;\t\tprivateKey, serverKS, err := config.generateKeyShare(ks.group)\t//ecdhe服务端生成公私钥\t\ths.hello13.keyShare = serverKS\t//公钥作为keyshare\tearlySecret, pskAlert := hs.checkPSK()\t// 检查psk，看能否session重用\tswitch &#123;\t...\tcase earlySecret != nil:\t\tc.didResume = true \t//ticket和binder验证通过。\t&#125;\ths.finishedHash13 = hash.New()\ths.finishedHash13.Write(hs.clientHello.marshal())\thandshakeCtx := hs.finishedHash13.Sum(nil)\t//client hello摘要\tearlyClientCipher, _ := hs.prepareCipher(handshakeCtx, earlySecret, &quot;client early traffic secret&quot;) //client_early_traffic_secret=Derive-Secret(earlySecret, &quot;client early traffic secret&quot;,hash(clientHello))\tecdheSecret := deriveECDHESecret(ks, privateKey)\t//客户端公钥和server私钥，根据曲线乘法，计算出对称密钥\t\ths.finishedHash13.Write(hs.hello13.marshal())\t//发送server  hello, 包含协商信息,  需要注意的是，服务端的keyshare没有使用私钥签名\tif _, err := c.writeRecord(recordTypeHandshake, hs.hello13.marshal()); err != nil &#123;\t\treturn err\t&#125;\t// 和不使用session重用一致，只是early secret使用resumption secret作为输入\t// 不再发送发送Certificate和CerficateVerify消息\t...\treturn nil&#125;func (hs *serverHandshakeState) checkPSK() (earlySecret []byte, alert alert) &#123;\tif hs.c.config.SessionTicketsDisabled &#123;\t\treturn nil, alertSuccess\t&#125;\tfoundDHE := false\tfor _, mode := range hs.clientHello.pskKeyExchangeModes &#123;\t\tif mode == pskDHEKeyExchange &#123;\t//只支持psk dhe模式\t\t\tfoundDHE = true\t\t\tbreak\t\t&#125;\t&#125;\tif !foundDHE &#123;\t\treturn nil, alertSuccess\t&#125;\thash := hashForSuite(hs.suite)\thashSize := hash.Size()\tfor i := range hs.clientHello.psks &#123;\t\tsessionTicket := append([]uint8&#123;&#125;, hs.clientHello.psks[i].identity...)\t\tif hs.c.config.SessionTicketSealer != nil &#123;\t\t\tvar ok bool\t\t\tsessionTicket, ok = hs.c.config.SessionTicketSealer.Unseal(hs.clientHelloInfo(), sessionTicket)\t\t\tif !ok &#123;\t\t\t\tcontinue\t\t\t&#125;\t\t&#125; else &#123;\t\t\tsessionTicket, _ = hs.c.decryptTicket(sessionTicket)\t//使用默认的session ticket key解密\t\t\tif sessionTicket == nil &#123;\t\t\t\tcontinue\t\t\t&#125;\t\t&#125;\t\ts := &amp;sessionState13&#123;&#125;\t//还原tls 1.3 session\t\tif s.unmarshal(sessionTicket) != alertSuccess &#123;\t\t\tcontinue\t\t&#125;\t\tif s.vers != hs.c.vers &#123;\t\t\tcontinue\t\t&#125;\t\t//client收到ticket后，通过lifetime，计算obfTicketAge，并加上随机值ageAdd，这里减回去，得到client的ticket有效时间\t\tclientAge := time.Duration(hs.clientHello.psks[i].obfTicketAge-s.ageAdd) * time.Millisecond\t//tls 1.3 ticket带时间了\t\tserverAge := time.Since(time.Unix(int64(s.createdAt), 0))\t\t//距离本次ticket的创建时间\t\tif clientAge-serverAge &gt; ticketAgeSkewAllowance || clientAge-serverAge &lt; -ticketAgeSkewAllowance &#123;\t\t\t// XXX: NSS is off spec and sends obfuscated_ticket_age as seconds\t\t\tclientAge = time.Duration(hs.clientHello.psks[i].obfTicketAge-s.ageAdd) * time.Second\t\t\tif clientAge-serverAge &gt; ticketAgeSkewAllowance || clientAge-serverAge &lt; -ticketAgeSkewAllowance &#123;\t\t\t\tcontinue\t\t\t&#125;\t\t&#125;\t\t// This enforces the stricter 0-RTT requirements on all ticket uses.\t\t// The benefit of using PSK+ECDHE without 0-RTT are small enough that\t\t// we can give them up in the edge case of changed suite or ALPN or SNI.\t\tif s.suite != hs.suite.id &#123;\t\t\tcontinue\t\t&#125;\t\tif s.alpnProtocol != hs.c.clientProtocol &#123;\t\t\tcontinue\t\t&#125;\t\tif s.SNI != hs.c.serverName &#123;\t\t\tcontinue\t\t&#125;\t\tearlySecret := hkdfExtract(hash, s.resumptionSecret, nil)\t// earlySecret = hkdfExtract(psk, 0); psk=resumption_master_secret\t\thandshakeCtx := hash.New().Sum(nil)\t\tbinderKey := hkdfExpandLabel(hash, earlySecret, handshakeCtx, &quot;resumption psk binder key&quot;, hashSize) //binder_key=Derive-Secret(early secret, &quot;resumption psk binder key&quot;, &quot;&quot;)\t\tbinderFinishedKey := hkdfExpandLabel(hash, binderKey, nil, &quot;finished&quot;, hashSize) //finished_key=Derive-Secret(binder_key, &quot;finished&quot;, &quot;&quot;)\t\tchHash := hash.New()\t\tchHash.Write(hs.clientHello.rawTruncated)\t//不包含psk扩展\t\texpectedBinder := hmacOfSum(hash, chHash, binderFinishedKey)\t//通过finishKey计算clienthello的hmac\t\tif subtle.ConstantTimeCompare(expectedBinder, hs.clientHello.psks[i].binder) != 1 &#123;\t//hmac验证\t\t\treturn nil, alertDecryptError\t\t&#125;\t\tif i == 0 &amp;&amp; hs.clientHello.earlyData &#123;\t\t\t// This is a ticket intended to be used for 0-RTT\t\t\tif s.maxEarlyDataLen == 0 &#123;\t\t\t\t// But we had not tagged it as such.\t\t\t\treturn nil, alertIllegalParameter\t\t\t&#125;\t\t\tif hs.c.config.Accept0RTTData &#123;\t//服务端支持0rtt， 0rtt会引起重放攻击\t\t\t\ths.c.binder = expectedBinder\t\t\t\ths.c.ticketMaxEarlyData = int64(s.maxEarlyDataLen)\t\t\t\ths.hello13Enc.earlyData = true\t\t\t&#125;\t\t&#125;\t\ths.hello13.psk = true\t\ths.hello13.pskIdentity = uint16(i)\t\treturn earlySecret, alertSuccess\t&#125;\treturn nil, alertSuccess&#125;func (c *Conn) handleEndOfEarlyData() &#123;\tif c.phase != readingEarlyData || c.vers &lt; VersionTLS13 &#123;\t\tc.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))\t\treturn\t&#125;\tc.phase = waitingClientFinished\tif c.hand.Len() &gt; 0 &#123;\t\tc.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))\t\treturn\t&#125;\tc.in.setCipher(c.vers, c.hs.hsClientCipher)\t//切换client的应用程序密钥&#125;\n\n记录层通过clientHello中带有short headers扩展， 删除了记录层开头的几个字节\nHKDF(HMAC-based key derivation function)HKDF是基于HMAC的密钥导出算法，用来替换TLS 1.3之前的PRF算法。\n\nHKDF follows the “extract-then-expand” paradigm, where the KDFlogically consists of two modules. The first stage takes the inputkeying material and “extracts” from it a fixed-length pseudorandomkey K. The second stage “expands” the key K into several additionalpseudorandom keys (the output of the KDF).\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051520\t\t\t\t             |\t\t\t\t             vPSK(resumption secret) -&gt;  HKDF-Extract = Early Secret\t\t\t\t             |\t\t\t\t             +-----&gt; Derive-Secret(.,\t\t\t\t             |                     &quot;external psk binder key&quot; |\t\t\t\t             |                     &quot;resumption psk binder key&quot;,\t\t\t\t             |                     &quot;&quot;)\t\t\t\t             |                     = binder_key\t\t\t\t             |\t\t\t\t             +-----&gt; Derive-Secret(., &quot;client early traffic secret&quot;,\t\t\t\t             |                     ClientHello)\t\t\t\t             |                     = client_early_traffic_secret\t\t\t\t             |\t\t\t\t             +-----&gt; Derive-Secret(., &quot;early exporter master secret&quot;,\t\t\t\t             |                     ClientHello)\t\t\t\t             |                     = early_exporter_master_secret\t\t\t\t             v\t\t\t\t       Derive-Secret(., &quot;derived secret&quot;, &quot;&quot;)\t\t\t\t             |\t\t\t\t             v\t\t\t\t(EC)DHE -&gt; HKDF-Extract = Handshake Secret\t\t\t\t             |\t\t\t\t             +-----&gt; Derive-Secret(., &quot;client handshake traffic secret&quot;,\t\t\t\t             |                     ClientHello...ServerHello)\t\t\t\t             |                     = client_handshake_traffic_secret\t\t\t\t             |\t\t\t\t             +-----&gt; Derive-Secret(., &quot;server handshake traffic secret&quot;,\t\t\t\t             |                     ClientHello...ServerHello)\t\t\t\t             |                     = server_handshake_traffic_secret\t\t\t\t             v\t\t\t\t       Derive-Secret(., &quot;derived secret&quot;, &quot;&quot;)\t\t\t\t             |\t\t\t\t             v\t\t\t\t  0 -&gt; HKDF-Extract = Master Secret\t\t\t\t             |\t\t\t\t             +-----&gt; Derive-Secret(., &quot;client application traffic secret&quot;,\t\t\t\t             |                     ClientHello...server Finished)\t\t\t\t             |                     = client_application_traffic_secret_0\t\t\t\t             |\t\t\t\t             +-----&gt; Derive-Secret(., &quot;server application traffic secret&quot;,\t\t\t\t             |                     ClientHello...server Finished)\t\t\t\t             |                     = server_application_traffic_secret_0\t\t\t\t             |\t\t\t\t             +-----&gt; Derive-Secret(., &quot;exporter master secret&quot;,\t\t\t\t             |                     ClientHello...server Finished)\t\t\t\t             |                     = exporter_master_secret\t\t\t\t             |\t\t\t\t             +-----&gt; Derive-Secret(., &quot;resumption master secret&quot;,\t\t\t\t                                   ClientHello...client Finished)\t\t\t\t                                   = resumption_master_secret\n\n","dateCreated":"2022-04-09T00:18:00+08:00","dateModified":"2022-04-09T10:33:35+08:00","datePublished":"2022-04-09T00:18:00+08:00","description":"写一篇关于 TLS 1.3 的文章","headline":"TLS 1.3 和 0-RTT","image":["https://lfs.libmbr.com/assets/2022/04/09/t1.webp"],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.libmbr.com/archives/429/"},"publisher":{"@type":"Organization","name":"MBRjun","sameAs":["https://github.com/MBRjun","https://twitter.com/MBRjun","mailto:neko@mbr.moe"],"image":"https://lfs.libmbr.com/assets/pics/LG4v5Ravatar180px.webp","logo":{"@type":"ImageObject","url":"https://lfs.libmbr.com/assets/pics/LG4v5Ravatar180px.webp"}},"url":"https://www.libmbr.com/archives/429/","keywords":"TCP, HTTPS, 0-RTT, TLS, TFO","thumbnailUrl":"https://lfs.libmbr.com/assets/2022/04/09/t1.webp"}</script><meta name="description" content="写一篇关于 TLS 1.3 的文章"><meta property="og:type" content="blog"><meta property="og:title" content="TLS 1.3 和 0-RTT"><meta property="og:url" content="https://www.libmbr.com/archives/429/index.html"><meta property="og:site_name" content="MBRjun-Blog"><meta property="og:description" content="写一篇关于 TLS 1.3 的文章"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-04-08T16:18:00.000Z"><meta property="article:modified_time" content="2022-04-09T02:33:35.000Z"><meta property="article:author" content="MBRjun"><meta property="article:tag" content="TCP"><meta property="article:tag" content="HTTPS"><meta property="article:tag" content="0-RTT"><meta property="article:tag" content="TLS"><meta property="article:tag" content="TFO"><meta name="twitter:card" content="summary"><meta name="twitter:creator" content="@MBRjun"><meta property="og:image" content="https://lfs.libmbr.com/assets/pics/LG4v5Ravatar180px.webp"><meta property="og:image" content="https://lfs.libmbr.com/assets/2022/04/09/t1.webp"><meta class="swiftype" name="image" data-type="enum" content="https://lfs.libmbr.com/assets/2022/04/09/t1.webp"><!--STYLES--><link rel="stylesheet" href="/assets/css/style.min.css?v=8a24506c1afe6dd0eb4a78082529f7d6a0f62837"><!--STYLES END--><!--SCRIPTS--><script async="" defer="" src="/assets/js/script.min.js?v=8a24506c1afe6dd0eb4a78082529f7d6a0f62837"></script><!--SCRIPTS END--><!--PRELOAD--><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="//github.githubassets.com"><link rel="dns-prefetch" href="//avatars.githubusercontent.com"><link rel="preconnect" href="https://lfs.libmbr.com"><link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="/assets/fonts/GoogleSansDisplay-BR.woff2"><link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="/assets/fonts/GoogleSansDisplay-LR.woff2"><link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="/assets/fonts/fa-solid-900.woff2"><link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="/assets/fonts/fa-brands-400.woff2"><!--PRELOAD END--><link rel="canonical" href="https://www.libmbr.com/archives/429/"><script>"use strict";var scripts=["/assets/js/webp-polyfill.min.js?v=2.0.1"];function parallelLoadScripts(e,t){"object"!=typeof e&&(e=[e]);for(var n=document.getElementsByTagName("head")[0]||document.documentElement,o=[],l=0,i=0;i<e.length;i++)o[i]=document.createElement("script"),o[i].setAttribute("type","text/javascript"),o[i].onload=o[i].onreadystatechange=function(){l++,this.onload=this.onreadystatechange=null,this.parentNode.removeChild(this),l===e.length&&"function"==typeof t&&t()},o[i].setAttribute("src",e[i]),n.appendChild(o[i])}"ActiveXObject"in window&&parallelLoadScripts(scripts,function(){console.log("[hexo-webp-polyfill] polyfilling document"),(new webpHero.WebpMachine).polyfillDocument()});</script></head><body><div id="blog"><!-- Define author's picture --><header id="header" data-behavior="2"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/" aria-label="">MBRjun-Blog</a></div><a class="header-right-picture" href="/about" aria-label="打开链接: /about"><img class="header-picture" src="https://lfs.libmbr.com/assets/pics/LG4v5Ravatar180px.webp" alt="作者的图片"></a></header><!-- Define author's picture --><nav id="sidebar" data-behavior="2"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about" aria-label="阅读有关作者的更多信息"><img class="sidebar-profile-picture" src="https://lfs.libmbr.com/assets/pics/LG4v5Ravatar180px.webp" alt="作者的图片"></a><h4 class="sidebar-profile-name">MBRjun</h4><h5 class="sidebar-profile-bio"><p>我们生活在大地上，但我们的梦想超越天空</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/" rel="noopener" title="首页"><i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories" rel="noopener" title="分类"><i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags" rel="noopener" title="标签"><i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives" rel="noopener" title="归档"><i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/links" rel="noopener" title="友情链接"><i class="sidebar-button-icon fa fa-link" aria-hidden="true"></i> <span class="sidebar-button-desc">友情链接</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="https://www.travellings.cn/go.html" target="_blank" rel="noopener" title="开往"><i class="sidebar-button-icon fa fa-paper-plane" aria-hidden="true"></i> <span class="sidebar-button-desc">开往</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/MBRjun" target="_blank" rel="noopener" title="GitHub"><i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="https://twitter.com/MBRjun" target="_blank" rel="noopener" title="Twitter"><i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i> <span class="sidebar-button-desc">Twitter</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto:neko@mbr.moe" target="_blank" rel="noopener" title="邮箱"><i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/atom.xml" rel="noopener" title="RSS"><i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i> <span class="sidebar-button-desc">RSS</span></a></li></ul></div></nav><div id="main" data-behavior="2" class="hasCoverMetaIn"><article class="post"><div class="post-header main-content-wrap text-left"><h1 class="post-title">TLS 1.3 和 0-RTT</h1><div class="post-meta"><time datetime="2022-04-09T00:18:00+08:00">2022 年 4 月 9 日 </time><span>发布在 </span><a class="category-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a></div></div><div class="post-content markdown"><div class="main-content-wrap"><p>写一篇关于 TLS 1.3 的文章</p><span id="more"></span><hr><p>首先需要明确的是，同等情况下，TLS1.3 比 1.2 少一个 RTT 时间。</p><p>客户端完成 TCP 握手需要一个 RTT 时间， TLS1.2 完成TLS 密钥协商需要两个 RTT 时间， TLS1.3 只需要一个 RTT 时间。<br>因此对于 https， 收到第一个 http 响应包，TLS1.2 需要 4 个 RTT 时间， TLS1.3 需要 3 个 RTT 时间。</p><p>考虑 session 重用，根据数据表明，大部分的 TLS 的请求都在重用， TLS1.2 session 重用需要一个 RTT 时间， TLS1.3 则因为在第一个包中携带数据，只需要0个 RTT，有点类似 TLS 层的TCP Fast Open。<br>因此对于 https， 收到第一个 http 响应包，比非重用减少一个 RTT， TLS1.2 需要3个 RTT 时间， TLS1.3 需要2个 RTT 时间。</p><p>另外如果开启 TCP 的 TFO，收到第一个 https 响应包的时间，则再减少一个 RTT，在 session 重用的时候就是 TLS1.2 需要2个 RTT，TLS1.3 只需要1个 RTT 时间。</p><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>为什么 TLS 1.3 能少一个 RTT 时间？</p><p>考虑 TLS 1.2, 下面握手流程来自 RFC5246 ，在第一个 RTT 需要协商算法版本等信息， 在第二个 RTT 才能完成对称密钥的协商。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Client                                        Server<br>ClientHello             --------&gt;<br>                                         ServerHello<br>                                        Certificate*<br>                                  ServerKeyExchange*<br>                                 CertificateRequest*<br>                        &lt;--------    ServerHelloDone<br>Certificate*<br>ClientKeyExchange<br>CertificateVerify*<br>[ChangeCipherSpec]<br>Finished                --------&gt;<br>                                  [ChangeCipherSpec]<br>                        &lt;--------           Finished<br>Application Data        &lt;-------&gt;   Application Data<br><br>    Figure 1.  Message flow for a full handshake<br></code></pre></td></tr></tbody></table></figure><p>如果要减少 RTT，就是解决如何在第一个 RTT 内就能完成密钥的协商？<br>因为 TLS 1.3 只支持 PFS 的算法，已经取消了 RSA 作为密钥协商算法， 因此以下讨论仅用 ECDHE 来说明。</p><p>使用 ECDHE 需要解决以下问题:</p><ul><li>双方把自己的公钥发送给对方</li><li>确认发送的公钥信息没有被中间人篡改</li></ul><p>很自然的，我们会考虑能不能把 ECDHE 的公钥在 client hello 中发送?<br>服务端收到 client hello 后，随机生成本地的 ECDHE 私钥后，就能直接能计算出 pre-master secret，进而计算出所有密钥。<br>同时服务端发送 finish 消息，通过 hmac 验证，client hello 中的 ECDHE 公钥没有被篡改。</p><p>在第二个 RTT 开始，收到 server hello 后，client 也能通过服务端 ECDHE 的公钥计算出 pre-master secret，<br>发送自己的 Finish 消息，并和应用数据一起发送。 服务端验证 Finish 成功后才接收数据。</p><p>上面分析，完全是拍脑袋的结果，事实上 TLS 1.3 是这样吗？</p><h2 id="TLS-1-3"><a href="#TLS-1-3" class="headerlink" title="TLS 1.3"></a>TLS 1.3</h2><p>对比TLS 1.2主要的修改如下:</p><ul><li>使用更严格的算法，只使用 PFS 的算法，如禁用了 RSA 密钥协商， 只使用 AEAD 算法</li><li>使用 HKDF 密钥导出算法替代 PRF 算法</li><li>server hello 之后的握手包也开始加密， 并去掉了changeCipherSpec 消息</li><li>更改了 session 重用机制， 使用 PSK 的机制，同时 session ticket 中添加了过期时间。 过去 TLS 1.2 中的 ticket 不包含过期时间，只能通过 ticket key 的更新让之前所有发送的 ticket 都失效</li><li>版本协商作为 client hello 的扩展，提供版本列表</li><li>支持 0-RTT 发送</li></ul><hr><p>后文所有的代码来源于下面两个库，<br>server 端源码来自 Cloudflare 的 <a target="_blank" rel="noopener" href="https://github.com/cloudflare/tls-tris">tls-tris</a>，Client 端参考了 <a target="_blank" rel="noopener" href="https://github.com/bifurcation/mint">bifurcation/mint</a></p><h1 id="clientHello"><a href="#clientHello" class="headerlink" title="clientHello"></a>clientHello</h1><p>如前文所述， TLS 1.3 为了减少一个 RTT 时间，必须在 client hello 中发送本地的 ECDHE 的公钥，因为可能支持多个曲线，所以需要发送每个曲线的 ECDHE 公钥。<br>每个公钥和对应的曲线， 称为 keyShare。 keyshare 列表作为 clientHello 的扩展被发送</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// 每个 keyShare 的条目，包含曲线 ID 和公钥<br>struct {<br>       NamedGroup group;<br>       opaque key_exchange&lt;1..2^16-1&gt;;<br>   } KeyShareEntry;<br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">func (h *ClientHandshake) CreateClientHello(opts ConnectionOptions, caps Capabilities) (*HandshakeMessage, error) {<br>	// key_shares<br>	h.OfferedDH = map[NamedGroup][]byte{}<br>	ks := KeyShareExtension{<br>		HandshakeType: HandshakeTypeClientHello,<br>		Shares:        make([]KeyShareEntry, len(caps.Groups)),<br>	}<br>	for i, group := range caps.Groups {<br>		pub, priv, err := newKeyShare(group)	//为每个支持的曲线，生成公私钥，作为keyshare<br>		if err != nil {<br>			return nil, err<br>		}<br>		ks.Shares[i].Group = group<br>		ks.Shares[i].KeyExchange = pub<br>		h.OfferedDH[group] = priv<br>	}<br>	...<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="serverHello"><a href="#serverHello" class="headerlink" title="serverHello"></a>serverHello</h2><h4 id="and-HelloRetryRequest-EncryptedExtensions-CertificateRequest-Certifacate-CertificateVerify-Finished"><a href="#and-HelloRetryRequest-EncryptedExtensions-CertificateRequest-Certifacate-CertificateVerify-Finished" class="headerlink" title="and HelloRetryRequest, EncryptedExtensions, CertificateRequest, Certifacate, CertificateVerify, Finished"></a>and HelloRetryRequest, EncryptedExtensions, CertificateRequest, Certifacate, CertificateVerify, Finished</h4><ul><li>服务端收到 client 后，协商曲线，如果有支持的曲线则使用该 keyshare， 否则发送 HelloRetryRequest 消息通知client。</li><li>服务端生成 ECDHE 公私钥后， 通过客户端的 keyShare 协商出密钥 ECDHESecret(TLS 1.2 中的 premaster secret)。然后通过 serverHello 发送服务端的 keyShare。<br>需要注意的是 keyShare 没有使用私钥签名， 整个过程的不可抵赖和防篡改是通过 certificateVerify 证明持有私钥，以及 finished 消息使用 hmac 验证历史消息来确定的。</li><li>serverHello 之后的握手消息需要加密，导出加密密钥。<br>通过 early secret 和 ECDHE secre t导出server_handshake_traffic_secret。<br>再从 server_handshake_traffic_secret 中导出 key 和 iv，使用该 key 和 iv 对 server hello 之后的握手消息加密。<br>同样的计算 client_handshake_traffic_secret，使用对应的 key 和 iv 进行解密后续的握手消息</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Derive-Secret(Secret, Label, Messages) =<br>         HKDF-Expand-Label(Secret, Label,<br>                           Transcript-Hash(Messages), Hash.length)<br>early secret=HKDF-Extract(0,0)<br>Handshake Secret = HKDF-Extract(ecdhe secret, early secret)<br>server_handshake_traffic_secret = Derive-Secret(Handshake Secret, "server handshake traffic secret", ClientHello...ServerHello) <br>client_handshake_traffic_secret = Derive-Secret(Handshake Secret, "server handshake traffic secret", ClientHello...ServerHello) <br>server_handshake_key := hkdfExpandLabel(hash, server_handshake_traffic_secret, nil, "key", hs.suite.keyLen)<br>server_handshake_iv := hkdfExpandLabel(hash, server_handshake_traffic_secret, nil, "iv", 12)<br>client_handshake_key := hkdfExpandLabel(hash, server_handshake_traffic_secret, nil, "key", hs.suite.keyLen)<br>client_handshake_iv := hkdfExpandLabel(hash, server_handshake_traffic_secret, nil, "iv", 12)<br></code></pre></td></tr></tbody></table></figure><ul><li>在 EncryptedExtensions 消息中发送扩展信息，比如 alpn 协议，服务端是否支持 earlyData</li><li>如果服务端需要客户端证书，则发送 CertificateRequest , 在其扩展中指定支持的签名算法和CA</li><li>发送 certificate 和 certificateVerify 消息<br>在 certificate 可以指定 OCSP stapling和 sct。<br>certificateVerify 跟以前 client 发送的类似， 使用私钥对历史握手消息的摘要进行签名, 并发送签名的算法。</li><li>发送 finished 消息, 从 server_handshake_traffic_secret 中导出 serverFinishedKey， 使用 hmac 计算 finished 后发送。 TLS 1.2 是使用 PRF(master_secret, digest(handshake)) 导出的。</li><li>导出最终的对称密钥。 先从 Handshake Secret 中导出 master secret，再从 master secret 导出两个方向的对称密钥 key 和 iv</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">masterSecret = hkdfExtract(hash, nil, Handshake Secret)<br>client_application_traffic_secret_0 = Derive-Secret(masterSecret, "client application traffic secret", ClientHello...server Finished)<br>server_application_traffic_secret_0 = Derive-Secret(masterSecret, "server application traffic secret", ClientHello...server Finished)<br></code></pre></td></tr></tbody></table></figure><h2 id="Certifacate"><a href="#Certifacate" class="headerlink" title="Certifacate"></a>Certifacate</h2><h4 id="and-CertificateVerify-Finished"><a href="#and-CertificateVerify-Finished" class="headerlink" title="and CertificateVerify, Finished"></a>and CertificateVerify, Finished</h4><p>客户端收到 serverHello 后，通过 server 的 keyshare 计算出 ECDHE secret。<br>然后跟 server 端一样，通过一系列的 khdf 密钥导出， 两个方向的后续握手密钥，以及 master secret 和两个方向的 application traffic secret。<br>因为 client 和 server 端 early secret 和协商出来的 ecdhe secret 相同， 因此所有后续导出的对应的密钥都是相同的。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">early secret=HKDF-Extract(0,0)<br>Handshake Secret = HKDF-Extract(ecdhe secret, early secret)<br>server_handshake_traffic_secret = Derive-Secret(Handshake Secret, "server handshake traffic secret", ClientHello...ServerHello)<br>client_handshake_traffic_secret = Derive-Secret(Handshake Secret, "client handshake traffic secret", ClientHello...ServerHello)<br>masterSecret = hkdfExtract(hash, nil, Handshake Secret)<br>client_application_traffic_secret_0 = Derive-Secret(masterSecret, "client application traffic secret", ClientHello...server Finished)<br>server_application_traffic_secret_0 = Derive-Secret(masterSecret, "server application traffic secret", ClientHello...server Finished)<br>resumption_master_secret = Derive-Secret(masterSecret, "resumption master secret",  hash(all handshake message))<br></code></pre></td></tr></tbody></table></figure><p>发送 finished 后， 就完成了整个握手信息， 通过 master secret 和整个握手的摘要，计算 resumption secret</p><h1 id="newSessionTicket"><a href="#newSessionTicket" class="headerlink" title="newSessionTicket"></a>newSessionTicket</h1><ul><li>收到客户端的 Certifacate 和 CertificateVerify，同样进行证书链的认证以及验证签名</li><li>服务端收到客户端的 finished 消息后，验证完后，同样计算 resumption secret</li><li>发送 new session ticket，包含整个 session 的信息。 newSessionTicket 使用server_application_traffic_secret 加密<br>在加密的ticket中，相比 TLS1.2，包含了当前的创建时间，因此可以方便的配置和验证 ticket 的过期时间。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">func (hs *serverHandshakeState) sendSessionTicket13() error {<br>	c := hs.c<br>	if c.config.SessionTicketsDisabled {<br>		return nil<br>	}<br>	foundDHE := false<br>	for _, mode := range hs.clientHello.pskKeyExchangeModes {<br>		if mode == pskDHEKeyExchange {<br>			foundDHE = true<br>			break<br>		}<br>	}<br>	if !foundDHE {<br>		return nil<br>	}<br>	//只支持dhe的方式计算psk<br>	hash := hashForSuite(hs.suite)<br>	handshakeCtx := hs.finishedHash13.Sum(nil)<br>	resumptionSecret := hkdfExpandLabel(hash, hs.masterSecret, handshakeCtx, "resumption master secret", hash.Size())<br>	ageAddBuf := make([]byte, 4)<br>	sessionState := &amp;sessionState13{		//需要加密的session信息，包含resumptionSecret<br>		vers:             c.vers,<br>		suite:            hs.suite.id,<br>		createdAt:        uint64(time.Now().Unix()),<br>		resumptionSecret: resumptionSecret,<br>		alpnProtocol:     c.clientProtocol,<br>		SNI:              c.serverName,<br>		maxEarlyDataLen:  c.config.Max0RTTDataSize,<br>	}<br>	for i := 0; i &lt; numSessionTickets; i++ {<br>		if _, err := io.ReadFull(c.config.rand(), ageAddBuf); err != nil {	//随机生成ageAddBuf<br>			c.sendAlert(alertInternalError)<br>			return err<br>		}<br>		sessionState.ageAdd = uint32(ageAddBuf[0])&lt;&lt;24 | uint32(ageAddBuf[1])&lt;&lt;16 |	//ageAdd使用随机值<br>			uint32(ageAddBuf[2])&lt;&lt;8 | uint32(ageAddBuf[3])<br>		ticket := sessionState.marshal()<br>		var err error<br>		if c.config.SessionTicketSealer != nil {<br>			cs := c.ConnectionState()<br>			ticket, err = c.config.SessionTicketSealer.Seal(&amp;cs, ticket)<br>		} else {<br>			ticket, err = c.encryptTicket(ticket)	//使用tiket key加密<br>		}<br>		if err != nil {<br>			c.sendAlert(alertInternalError)<br>			return err<br>		}<br>		if ticket == nil {<br>			continue<br>		}<br>		ticketMsg := &amp;newSessionTicketMsg13{<br>			lifetime:           24 * 3600, // TODO(filippo)	//24小时<br>			maxEarlyDataLength: c.config.Max0RTTDataSize,<br>			withEarlyDataInfo:  c.config.Max0RTTDataSize &gt; 0,<br>			ageAdd:             sessionState.ageAdd,	//随机值<br>			ticket:             ticket,	//session信息<br>		}<br>		if _, err := c.writeRecord(recordTypeHandshake, ticketMsg.marshal()); err != nil {<br>			return err<br>		}<br>	}<br>	return nil<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="session-重用和-0-RTT"><a href="#session-重用和-0-RTT" class="headerlink" title="session 重用和 0-RTT"></a>session 重用和 0-RTT</h2><p>client 收到 NewSessionTicket 消息后,<br>收到的 ticket 和客户端本地发送 finished 后计算的 resumptionSecret，两者一起组成了 PreSharedKey，即 PSK。<br>然后 client 把 PSK 保存到本地 cache 中， serverName 作为 cache 的 key。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">func (h *ClientHandshake) HandleNewSessionTicket(hm *HandshakeMessage) (PreSharedKey, error) {<br>	var tkt NewSessionTicketBody<br>	_, err := tkt.Unmarshal(hm.body)<br>	<br>	psk := PreSharedKey{<br>		CipherSuite:  h.Context.suite,<br>		IsResumption: true,<br>		Identity:     tkt.Ticket,		// ticket 中也包含 resumptionSecret，但是被加密<br>		Key:          h.Context.resumptionSecret,		//客户端本地发送 finished 后计算的 resumptionSecret<br>	}<br>	return psk, nil<br>}<br>c.config.PSKs.Put(c.config.ServerName, psk)		//这里使用 serverName 做为 key<br></code></pre></td></tr></tbody></table></figure><h2 id="client"><a href="#client" class="headerlink" title="client"></a>client</h2><p>在 client hello 中，会在本地 cache 中查找 servername 对应的 PSK， 找到后则在 client hello 的 psk 扩展中带上两部分</p><ul><li>Identity: 就是 NewSessionTicket 中加密的 ticket</li><li>Binder: 从之前 client 发送 finished 计算的 resumption secret，导出 early secret，进而导出后续的 binderKey 和 binder_macKey， 使用 binder_macKey 对不包含 PSK 部分的 clientHello 作HMAC</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Early Secret = HKDF-Extract(0, resumption secret)<br>binder_key = deriveSecret(Early Secret, "resumption psk binder key", "")<br>binder_macKey = hkdfExpandLabel(ctx.params.hash, binder_key, "finished", []byte{}, ctx.params.hash.Size())<br>earlyTrafficSecret = ctx.deriveSecret(Early Secret, "client early traffic secret", clientHello)<br>earlyExporterSecret = ctx.deriveSecret(Early Secret, "early exporter master secret", ClientHello)<br>clientEarlyTrafficKey,  clientEarlyTrafficIv= ctx.makeTrafficKeys(earlyTrafficSecret)<br></code></pre></td></tr></tbody></table></figure><p>通过 resumption secret 最终导出 earlyData 的加密密钥，以及 PSK 扩展中 binder 的 hmac 密钥。<br>发送 clientHello 后，使用 resumption secret 导出的 clientEarlyTrafficKey 和 IV，对 early data 加密后发送。</p><p><em>需要注意的是 earlydata 在 ticket 有效期内，不能防止重放攻击。</em></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">func (h *ClientHandshake) CreateClientHello(opts ConnectionOptions, caps Capabilities) (*HandshakeMessage, error) {<br>	// key_shares<br>	h.OfferedDH = map[NamedGroup][]byte{}<br>	ks := KeyShareExtension{<br>		HandshakeType: HandshakeTypeClientHello,<br>		Shares:        make([]KeyShareEntry, len(caps.Groups)),<br>	}<br>	for i, group := range caps.Groups {<br>		pub, priv, err := newKeyShare(group)	//为每个支持的曲线，生成公私钥，作为keyshare<br>		if err != nil {<br>			return nil, err<br>		}<br>		ks.Shares[i].Group = group<br>		ks.Shares[i].KeyExchange = pub<br>		h.OfferedDH[group] = priv<br>	}<br>	...<br>	if key, ok := caps.PSKs.Get(opts.ServerName); ok { //从cache中获取PSK，尝试session重用<br>		h.OfferedPSK = key<br>		keyParams, ok := cipherSuiteMap[key.CipherSuite]<br>		compatibleSuites := []CipherSuite{}<br>		for _, suite := range ch.CipherSuites {<br>			if cipherSuiteMap[suite].hash == keyParams.hash {<br>				compatibleSuites = append(compatibleSuites, suite)<br>			}<br>		}<br>		ch.CipherSuites = compatibleSuites	//更新psk能使用的算法<br>		if opts.EarlyData != nil {		//使用psk的话可以使用0-rtt发送early data<br>			ed = &amp;EarlyDataExtension{}	//开启early data<br>			ch.Extensions.Add(ed)<br>		}<br>		<br>		psk = &amp;PreSharedKeyExtension{<br>			HandshakeType: HandshakeTypeClientHello,<br>			Identities: []PSKIdentity{<br>				{Identity: key.Identity},	//Identity就是加密的ticket<br>			},<br>			Binders: []PSKBinderEntry{<br>				// Note: Stub to get the length fields right<br>				{Binder: bytes.Repeat([]byte{0x00}, keyParams.hash.Size())},<br>			},<br>		}<br>		ch.Extensions.Add(psk)	//添加psk作为client hello的扩展<br>		h.Context.preInit(key)	//从resumption secret导出early secret-&gt;binder key<br>		trunc, err := ch.Truncated()	//clientHello减去psk 扩展部分<br>		truncHash := h.Context.params.hash.New()<br>		truncHash.Write(trunc)<br>		binder := h.Context.computeFinishedData(h.Context.binderKey, truncHash.Sum(nil))	//binder_key导出macKey, 计算clientHello hmac<br>		// Replace the PSK extension<br>		psk.Binders[0].Binder = binder	//client hello的hmac<br>		ch.Extensions.Add(psk) //替换psk扩展<br>		h.clientHello, err = HandshakeMessageFromBody(ch)	//重新构造client hello<br>		<br>		h.Context.earlyUpdateWithClientHello(h.clientHello)	//导出client_early_traffic_secret及其key和iv，作为0-RTT的early data的密钥<br>	}<br>	...<br>}<br>func (c *Conn) clientHandshake() error {<br>	logf(logTypeHandshake, "Starting clientHandshake")<br>	h := &amp;ClientHandshake{}<br>	hIn := NewHandshakeLayer(c.in)<br>	hOut := NewHandshakeLayer(c.out)<br>	// Generate ClientHello<br>	caps := Capabilities{<br>		CipherSuites:     c.config.CipherSuites,<br>		Groups:           c.config.Groups,<br>		SignatureSchemes: c.config.SignatureSchemes,<br>		PSKs:             c.config.PSKs,<br>		PSKModes:         c.config.PSKModes,<br>		Certificates:     c.config.Certificates,<br>	}<br>	opts := ConnectionOptions{<br>		ServerName: c.config.ServerName,<br>		NextProtos: c.config.NextProtos,<br>		EarlyData:  c.earlyData,<br>	}<br>	chm, err := h.CreateClientHello(opts, caps)<br>	if err != nil {<br>		return err<br>	}<br>	// Write ClientHello<br>	err = hOut.WriteMessage(chm)<br>	if err != nil {<br>		return err<br>	}<br>	if opts.EarlyData != nil {	//使用client_early_traffic_secret的key/iv加密early data， 支持0-rtt发送<br>		// Rekey output to early data keys<br>		err = c.out.Rekey(h.Context.params.cipher, h.Context.clientEarlyTrafficKeys.key, h.Context.clientEarlyTrafficKeys.iv)<br>		// Send early application data<br>		logf(logTypeHandshake, "[client] Sending data...")<br>		_, err = c.Write(opts.EarlyData)<br>		if err != nil {<br>			return err<br>		}<br>		// Send end_of_earlyData<br>		logf(logTypeHandshake, "[client] Sending end_of_early_data...")<br>		err = c.sendAlert(AlertEndOfEarlyData)	//发送end_of_early_data alert标记early data结束<br>		if err != nil {<br>			return err<br>		}<br>	}<br>	...<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><p>和 TLS 1.2 之前不同， session 重用，使用的不是过去的 master secret。<br>TLS1.2 加密 ticket 后使用过去的 master secret，然后和两个随机数作为参数，一起 PRF 导出密钥。<br>而 TLS 1.3 只使用过去的 resumption secret 导出 early data 的密钥， 之后的密钥会和 ECDHE secret，一起导出。</p><ul><li>服务端收到 client hello 后，生成本地的 keyShare</li><li>检查 client hello 的 PSK 扩展， 解密 ticket，查看该 ticket 是否过期，已经版本算法等协商结果是否可用，然后使用 ticket 中的 resumption secret 计算 client hello 的 hmac， 检查 binder 是否正确。</li><li>验证完 ticket 和 binder 之后，在 serverHello 中表示使用 PSK，以及哪个 PSK。</li><li>和 client 一样，从 resumtion secret 中导出 earlyData 使用的密钥</li><li>和不使用 session 重用一样，导出后续的密钥，唯一不同的是 resumption secret 作为 early secret 的输入</li><li>收到 endOfEarlyData alert 后，切换到 client 方向的应用程序密钥</li><li>serverHello 发送后依然会发送 EncryptedExtensions 和 Finished 消息，但不会再发送 Certificate 和 CerficateVerify 消息。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">func (hs *serverHandshakeState) doTLS13Handshake() error {<br>	<br>	var ks keyShare<br>CurvePreferenceLoop:<br>	for _, curveID := range config.curvePreferences() {	// tls 1.3所有的曲线，都必须生成对应的keyshare， keyshare中包含dh的公钥<br>		for _, keyShare := range hs.clientHello.keyShares {<br>			if curveID == keyShare.group {<br>				ks = keyShare<br>				break CurvePreferenceLoop<br>			}<br>		}<br>	}<br>	<br>	privateKey, serverKS, err := config.generateKeyShare(ks.group)	//ecdhe服务端生成公私钥	<br>	hs.hello13.keyShare = serverKS	//公钥作为keyshare<br>	earlySecret, pskAlert := hs.checkPSK()	// 检查psk，看能否session重用<br>	switch {<br>	...<br>	case earlySecret != nil:<br>		c.didResume = true 	//ticket和binder验证通过。<br>	}<br>	hs.finishedHash13 = hash.New()<br>	hs.finishedHash13.Write(hs.clientHello.marshal())<br>	handshakeCtx := hs.finishedHash13.Sum(nil)	//client hello摘要<br>	earlyClientCipher, _ := hs.prepareCipher(handshakeCtx, earlySecret, "client early traffic secret") //client_early_traffic_secret=Derive-Secret(earlySecret, "client early traffic secret",hash(clientHello))<br>	ecdheSecret := deriveECDHESecret(ks, privateKey)	//客户端公钥和server私钥，根据曲线乘法，计算出对称密钥<br>	<br>	hs.finishedHash13.Write(hs.hello13.marshal())<br>	//发送server  hello, 包含协商信息,  需要注意的是，服务端的keyshare没有使用私钥签名<br>	if _, err := c.writeRecord(recordTypeHandshake, hs.hello13.marshal()); err != nil {<br>		return err<br>	}<br>	// 和不使用session重用一致，只是early secret使用resumption secret作为输入<br>	// 不再发送发送Certificate和CerficateVerify消息<br>	...<br>	return nil<br>}<br>func (hs *serverHandshakeState) checkPSK() (earlySecret []byte, alert alert) {<br>	if hs.c.config.SessionTicketsDisabled {<br>		return nil, alertSuccess<br>	}<br>	foundDHE := false<br>	for _, mode := range hs.clientHello.pskKeyExchangeModes {<br>		if mode == pskDHEKeyExchange {	//只支持psk dhe模式<br>			foundDHE = true<br>			break<br>		}<br>	}<br>	if !foundDHE {<br>		return nil, alertSuccess<br>	}<br>	hash := hashForSuite(hs.suite)<br>	hashSize := hash.Size()<br>	for i := range hs.clientHello.psks {<br>		sessionTicket := append([]uint8{}, hs.clientHello.psks[i].identity...)<br>		if hs.c.config.SessionTicketSealer != nil {<br>			var ok bool<br>			sessionTicket, ok = hs.c.config.SessionTicketSealer.Unseal(hs.clientHelloInfo(), sessionTicket)<br>			if !ok {<br>				continue<br>			}<br>		} else {<br>			sessionTicket, _ = hs.c.decryptTicket(sessionTicket)	//使用默认的session ticket key解密<br>			if sessionTicket == nil {<br>				continue<br>			}<br>		}<br>		s := &amp;sessionState13{}	//还原tls 1.3 session<br>		if s.unmarshal(sessionTicket) != alertSuccess {<br>			continue<br>		}<br>		if s.vers != hs.c.vers {<br>			continue<br>		}<br>		//client收到ticket后，通过lifetime，计算obfTicketAge，并加上随机值ageAdd，这里减回去，得到client的ticket有效时间<br>		clientAge := time.Duration(hs.clientHello.psks[i].obfTicketAge-s.ageAdd) * time.Millisecond	//tls 1.3 ticket带时间了<br>		serverAge := time.Since(time.Unix(int64(s.createdAt), 0))		//距离本次ticket的创建时间<br>		if clientAge-serverAge &gt; ticketAgeSkewAllowance || clientAge-serverAge &lt; -ticketAgeSkewAllowance {<br>			// XXX: NSS is off spec and sends obfuscated_ticket_age as seconds<br>			clientAge = time.Duration(hs.clientHello.psks[i].obfTicketAge-s.ageAdd) * time.Second<br>			if clientAge-serverAge &gt; ticketAgeSkewAllowance || clientAge-serverAge &lt; -ticketAgeSkewAllowance {<br>				continue<br>			}<br>		}<br>		// This enforces the stricter 0-RTT requirements on all ticket uses.<br>		// The benefit of using PSK+ECDHE without 0-RTT are small enough that<br>		// we can give them up in the edge case of changed suite or ALPN or SNI.<br>		if s.suite != hs.suite.id {<br>			continue<br>		}<br>		if s.alpnProtocol != hs.c.clientProtocol {<br>			continue<br>		}<br>		if s.SNI != hs.c.serverName {<br>			continue<br>		}<br>		earlySecret := hkdfExtract(hash, s.resumptionSecret, nil)	// earlySecret = hkdfExtract(psk, 0); psk=resumption_master_secret<br>		handshakeCtx := hash.New().Sum(nil)<br>		binderKey := hkdfExpandLabel(hash, earlySecret, handshakeCtx, "resumption psk binder key", hashSize) //binder_key=Derive-Secret(early secret, "resumption psk binder key", "")<br>		binderFinishedKey := hkdfExpandLabel(hash, binderKey, nil, "finished", hashSize) //finished_key=Derive-Secret(binder_key, "finished", "")<br>		chHash := hash.New()<br>		chHash.Write(hs.clientHello.rawTruncated)	//不包含psk扩展<br>		expectedBinder := hmacOfSum(hash, chHash, binderFinishedKey)	//通过finishKey计算clienthello的hmac<br>		if subtle.ConstantTimeCompare(expectedBinder, hs.clientHello.psks[i].binder) != 1 {	//hmac验证<br>			return nil, alertDecryptError<br>		}<br>		if i == 0 &amp;&amp; hs.clientHello.earlyData {<br>			// This is a ticket intended to be used for 0-RTT<br>			if s.maxEarlyDataLen == 0 {<br>				// But we had not tagged it as such.<br>				return nil, alertIllegalParameter<br>			}<br>			if hs.c.config.Accept0RTTData {	//服务端支持0rtt， 0rtt会引起重放攻击<br>				hs.c.binder = expectedBinder<br>				hs.c.ticketMaxEarlyData = int64(s.maxEarlyDataLen)<br>				hs.hello13Enc.earlyData = true<br>			}<br>		}<br>		hs.hello13.psk = true<br>		hs.hello13.pskIdentity = uint16(i)<br>		return earlySecret, alertSuccess<br>	}<br>	return nil, alertSuccess<br>}<br>func (c *Conn) handleEndOfEarlyData() {<br>	if c.phase != readingEarlyData || c.vers &lt; VersionTLS13 {<br>		c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))<br>		return<br>	}<br>	c.phase = waitingClientFinished<br>	if c.hand.Len() &gt; 0 {<br>		c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))<br>		return<br>	}<br>	c.in.setCipher(c.vers, c.hs.hsClientCipher)	//切换client的应用程序密钥<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="记录层"><a href="#记录层" class="headerlink" title="记录层"></a>记录层</h2><p>通过clientHello中带有short headers扩展， 删除了记录层开头的几个字节</p><h2 id="HKDF"><a href="#HKDF" class="headerlink" title="HKDF"></a>HKDF</h2><h4 id="HMAC-based-key-derivation-function"><a href="#HMAC-based-key-derivation-function" class="headerlink" title="(HMAC-based key derivation function)"></a>(HMAC-based key derivation function)</h4><p>HKDF是基于HMAC的密钥导出算法，用来替换TLS 1.3之前的PRF算法。</p><blockquote><p>HKDF follows the “extract-then-expand” paradigm, where the KDF<br>logically consists of two modules. The first stage takes the input<br>keying material and “extracts” from it a fixed-length pseudorandom<br>key K. The second stage “expands” the key K into several additional<br>pseudorandom keys (the output of the KDF).</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">0<br>				             |<br>				             v<br>PSK(resumption secret) -&gt;  HKDF-Extract = Early Secret<br>				             |<br>				             +-----&gt; Derive-Secret(.,<br>				             |                     "external psk binder key" |<br>				             |                     "resumption psk binder key",<br>				             |                     "")<br>				             |                     = binder_key<br>				             |<br>				             +-----&gt; Derive-Secret(., "client early traffic secret",<br>				             |                     ClientHello)<br>				             |                     = client_early_traffic_secret<br>				             |<br>				             +-----&gt; Derive-Secret(., "early exporter master secret",<br>				             |                     ClientHello)<br>				             |                     = early_exporter_master_secret<br>				             v<br>				       Derive-Secret(., "derived secret", "")<br>				             |<br>				             v<br>				(EC)DHE -&gt; HKDF-Extract = Handshake Secret<br>				             |<br>				             +-----&gt; Derive-Secret(., "client handshake traffic secret",<br>				             |                     ClientHello...ServerHello)<br>				             |                     = client_handshake_traffic_secret<br>				             |<br>				             +-----&gt; Derive-Secret(., "server handshake traffic secret",<br>				             |                     ClientHello...ServerHello)<br>				             |                     = server_handshake_traffic_secret<br>				             v<br>				       Derive-Secret(., "derived secret", "")<br>				             |<br>				             v<br>				  0 -&gt; HKDF-Extract = Master Secret<br>				             |<br>				             +-----&gt; Derive-Secret(., "client application traffic secret",<br>				             |                     ClientHello...server Finished)<br>				             |                     = client_application_traffic_secret_0<br>				             |<br>				             +-----&gt; Derive-Secret(., "server application traffic secret",<br>				             |                     ClientHello...server Finished)<br>				             |                     = server_application_traffic_secret_0<br>				             |<br>				             +-----&gt; Derive-Secret(., "exporter master secret",<br>				             |                     ClientHello...server Finished)<br>				             |                     = exporter_master_secret<br>				             |<br>				             +-----&gt; Derive-Secret(., "resumption master secret",<br>				                                   ClientHello...client Finished)<br>				                                   = resumption_master_secret<br></code></pre></td></tr></tbody></table></figure></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small t-none-link" href="/tags/0-RTT/" rel="tag">0-RTT</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/HTTPS/" rel="tag">HTTPS</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/TCP/" rel="tag">TCP</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/TFO/" rel="tag">TFO</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/TLS/" rel="tag">TLS</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/archives/430/" data-tooltip="解决 OpenWrt ZeroTier 报错 Error relocating" aria-label="上一篇: 解决 OpenWrt ZeroTier 报错 Error relocating"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/archives/424/" data-tooltip="腾讯云 CVM 配置 IPv6 简易教程" aria-label="下一篇: 腾讯云 CVM 配置 IPv6 简易教程"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://www.libmbr.com/archives/429/" title="分享到 Twitter" aria-label="分享到 Twitter"><i class="fab fa-twitter" aria-hidden="true"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://www.libmbr.com/archives/429/" title="分享到 Weibo" aria-label="分享到 Weibo"><i class="fab fa-weibo" aria-hidden="true"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.libmbr.com/archives/429/&amp;title=TLS 1.3 和 0-RTT" title="分享到 QQ" aria-label="分享到 QQ"><i class="fab fa-qq" aria-hidden="true"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://www.libmbr.com/archives/429/" title="分享到 Qzone" aria-label="分享到 Qzone"><i class="fa fa-star" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div><script src="https://hiroko.libmbr.com/client.js" data-repo="MBRjun/MBRjun-Blog" data-repo-id="R_kgDOIbI33Q" data-category="Blog" data-category-id="DIC_kwDOIbI33c4CTUTq" data-mapping="title" data-strict="1" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light_tritanopia" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" async=""></script></div></article><footer id="footer" class="main-content-wrap"><span class="copyrights"><a target="_blank" rel="noopener" href="https://github.com/MBRjun/MBRjun-Blog">GitHub 源代码</a> - <a target="_blank" rel="noopener" href="https://github.com/MBRjun/MBRjun-Blog/blob/main/LICENSE">LICENSE(CC BY-SA 3)</a><br></span><span class="text-small"><a target="_blank" href="https://beian.miit.gov.cn" rel="nofollow noopener">闽ICP备2025085162号-4</a> - <a target="_blank" href="http://www.beian.gov.cn" rel="nofollow noopener">津公网安备12010102001086号</a><br></span><span class="copyrights">Copyrights © 2025 MBRjun. All Rights Reserved.</span></footer><script async="" defer="" data-website-id="8bccd081-57f0-4d61-908d-38e37d47241d" src="https://hotaru.libmbr.com/hotaru.js?v=20250329-1" data-tag="MBRjun-Blog"></script></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="2"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/archives/430/" data-tooltip="解决 OpenWrt ZeroTier 报错 Error relocating" aria-label="上一篇: 解决 OpenWrt ZeroTier 报错 Error relocating"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/archives/424/" data-tooltip="腾讯云 CVM 配置 IPv6 简易教程" aria-label="下一篇: 腾讯云 CVM 配置 IPv6 简易教程"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://www.libmbr.com/archives/429/" title="分享到 Twitter" aria-label="分享到 Twitter"><i class="fab fa-twitter" aria-hidden="true"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://www.libmbr.com/archives/429/" title="分享到 Weibo" aria-label="分享到 Weibo"><i class="fab fa-weibo" aria-hidden="true"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.libmbr.com/archives/429/&amp;title=TLS 1.3 和 0-RTT" title="分享到 QQ" aria-label="分享到 QQ"><i class="fab fa-qq" aria-hidden="true"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://www.libmbr.com/archives/429/" title="分享到 Qzone" aria-label="分享到 Qzone"><i class="fa fa-star" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div><div id="share-options-bar" class="share-options-bar" data-behavior="2"><i id="btn-close-shareoptions" class="fa fa-times"></i><ul class="share-options"><li class="share-option"><a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=https://www.libmbr.com/archives/429/" aria-label="分享到 Twitter"><i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span></a></li><li class="share-option"><a class="share-option-btn" target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://www.libmbr.com/archives/429/" aria-label="分享到 Weibo"><i class="fab fa-weibo" aria-hidden="true"></i><span>分享到 Weibo</span></a></li><li class="share-option"><a class="share-option-btn" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.libmbr.com/archives/429/&amp;title=TLS 1.3 和 0-RTT" aria-label="分享到 QQ"><i class="fab fa-qq" aria-hidden="true"></i><span>分享到 QQ</span></a></li><li class="share-option"><a class="share-option-btn" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://www.libmbr.com/archives/429/" aria-label="分享到 Qzone"><i class="fa fa-star" aria-hidden="true"></i><span>分享到 Qzone</span></a></li></ul></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-times"></i></div><img id="about-card-picture" src="https://lfs.libmbr.com/assets/pics/LG4v5Ravatar180px.webp" alt="作者的图片"><h4 id="about-card-name">MBRjun</h4><div id="about-card-bio"><p>我们生活在大地上，但我们的梦想超越天空</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>学生</p></div><div id="about-card-location"><i class="fa fa-map-marker-alt"></i><br>地球</div></div></div><div id="cover" style="background-image:url('https://lfs.libmbr.com/assets/2023/03/23/4419f34e-9353-4b44-a6dd-ebb1db958fc5.webp');"></div><!-- 
█▀▄▀█ █▄▄ █▀█ ░░█ █░█ █▄░█ ▄▄ █▄▄ █░░ █▀█ █▀▀
█░▀░█ █▄█ █▀▄ █▄█ █▄█ █░▀█ ░░ █▄█ █▄▄ █▄█ █▄█
MBRjun-Blog 2025 - with Hexo 7 - tk-mbr NYA-
Commit 8a24506c1afe6dd0eb4a78082529f7d6a0f62837
Build on: runner@runnervmf4ws1 (running kernel: 6.11.0-1018-azure)
Date: 2025-09-21 Preset: CI --></body></html>